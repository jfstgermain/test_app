{"ts":1351696424564,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1351696432010,"patch":[[{"diffs":[[1,"// -- Sammy.js -- /sammy.js\r\n// http://sammyjs.org\r\n// Version: 0.7.2\r\n// Built: 2012-10-19 23:50:30 -0400\r\n// name: sammy\r\n// version: 0.7.2\r\n// Sammy.js / http://sammyjs.org\r\n(function(e,t){(function(n){typeof define==\"function\"&&define.amd?define([\"jquery\"],n):e.sammy=t.Sammy=n(e)})(function(e){var n,r=\"([^/]+)\",i=/:([\\w\\d]+)/g,s=/\\?([^#]*)?$/,o=function(e){return Array.prototype.slice.call(e)},u=function(e){return Object.prototype.toString.call(e)===\"[object Function]\"},a=function(e){return Object.prototype.toString.call(e)===\"[object Array]\"},f=function(e){return Object.prototype.toString.call(e)===\"[object RegExp]\"},l=function(e){return decodeURIComponent((e||\"\").replace(/\\+/g,\" \"))},c=encodeURIComponent,h=function(e){return String(e).replace(/&(?!\\w+;)/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\").replace(/\"/g,\"&quot;\")},p=function(e){return function(t,n){return this.route.apply(this,[e,t,n])}},d={},v=!!t.history&&!!history.pushState,m=[];return n=function(){var t=o(arguments),r,i;n.apps=n.apps||{};if(t.length===0||t[0]&&u(t[0]))return n.apply(n,[\"body\"].concat(t));if(typeof (i=t.shift())==\"string\")return r=n.apps[i]||new n.Application,r.element_selector=i,t.length>0&&e.each(t,function(e,t){r.use(t)}),r.element_selector!=i&&delete n.apps[i],n.apps[r.element_selector]=r,r},n.VERSION=\"0.7.2\",n.addLogger=function(e){m.push(e)},n.log=function(){var t=o(arguments);t.unshift(\"[\"+Date()+\"]\"),e.each(m,function(e,r){r.apply(n,t)})},typeof t.console!=\"undefined\"?u(t.console.log.apply)?n.addLogger(function(){t.console.log.apply(t.console,arguments)}):n.addLogger(function(){t.console.log(arguments)}):typeof console!=\"undefined\"&&n.addLogger(function(){console.log.apply(console,arguments)}),e.extend(n,{makeArray:o,isFunction:u,isArray:a}),n.Object=function(t){return e.extend(this,t||{})},e.extend(n.Object.prototype,{escapeHTML:h,h:h,toHash:function(){var t={};return e.each(this,function(e,n){u(n)||(t[e]=n)}),t},toHTML:function(){var t=\"\";return e.each(this,function(e,n){u(n)||(t+=\"<strong>\"+e+\"</strong> \"+n+\"<br />\")}),t},keys:function(e){var t=[];for(var n in this)(!u(this[n])||!e)&&t.push(n);return t},has:function(t){return this[t]&&e.trim(this[t].toString())!==\"\"},join:function(){var e=o(arguments),t=e.shift();return e.join(t)},log:function(){n.log.apply(n,arguments)},toString:function(t){var n=[];return e.each(this,function(e,r){(!u(r)||t)&&n.push('\"'+e+'\": '+r.toString())}),\"Sammy.Object: {\"+n.join(\",\")+\"}\"}}),n.DefaultLocationProxy=function(e,t){this.app=e,this.is_native=!1,this.has_history=v,this._startPolling(t)},n.DefaultLocationProxy.fullPath=function(e){var t=e.toString().match(/^[^#]*(#.+)$/),n=t?t[1]:\"\";return[e.pathname,e.search,n].join(\"\")},e.extend(n.DefaultLocationProxy.prototype,{bind:function(){var r=this,i=this.app,s=n.DefaultLocationProxy;e(t).bind(\"hashchange.\"+this.app.eventNamespace(),function(e,n){r.is_native===!1&&!n&&(r.is_native=!0,t.clearInterval(s._interval)),i.trigger(\"location-changed\")}),v&&!i.disable_push_state&&(e(t).bind(\"popstate.\"+this.app.eventNamespace(),function(e){i.trigger(\"location-changed\")}),e(\"a\").live(\"click.history-\"+this.app.eventNamespace(),function(e){if(e.isDefaultPrevented()||e.metaKey||e.ctrlKey)return;var n=s.fullPath(this);if(this.hostname==t.location.hostname&&i.lookupRoute(\"get\",n)&&this.target!==\"_blank\")return e.preventDefault(),r.setLocation(n),!1})),s._bindings||(s._bindings=0),s._bindings++},unbind:function(){e(t).unbind(\"hashchange.\"+this.app.eventNamespace()),e(t).unbind(\"popstate.\"+this.app.eventNamespace()),e(\"a\").die(\"click.history-\"+this.app.eventNamespace()),n.DefaultLocationProxy._bindings--,n.DefaultLocationProxy._bindings<=0&&t.clearInterval(n.DefaultLocationProxy._interval)},getLocation:function(){return n.DefaultLocationProxy.fullPath(t.location)},setLocation:function(e){/^([^#\\/]|$)/.test(e)&&(v&&!this.app.disable_push_state?e=\"/\"+e:e=\"#!/\"+e);if(e!=this.getLocation()){if(!(v&&!this.app.disable_push_state&&/^\\//.test(e)))return t.location=e;history.pushState({path:e},t.title,e),this.app.trigger(\"location-changed\")}},_startPolling:function(r){var i=this;if(!n.DefaultLocationProxy._interval){r||(r=10);var s=function(){var r=i.getLocation();(typeof n.DefaultLocationProxy._last_location==\"undefined\"||r!=n.DefaultLocationProxy._last_location)&&t.setTimeout(function(){e(t).trigger(\"hashchange\",[!0])},0),n.DefaultLocationProxy._last_location=r};s(),n.DefaultLocationProxy._interval=t.setInterval(s,r)}}}),n.Application=function(e){var t=this;this.routes={},this.listeners=new n.Object({}),this.arounds=[],this.befores=[],this.namespace=(new Date).getTime()+\"-\"+parseInt(Math.random()*1e3,10),this.context_prototype=function(){n.EventContext.apply(this,arguments)},this.context_prototype.prototype=new n.EventContext,u(e)&&e.apply(this,[this]),this._location_proxy||this.setLocationProxy(new n.DefaultLocationProxy(this,this.run_interval_every)),this.debug&&this.bindToAllEvents(function(e,n){t.log(t.toString(),e.cleaned_type,n||{})})},n.Application.prototype=e.extend({},n.Object.prototype,{ROUTE_VERBS:[\"get\",\"post\",\"put\",\"delete\"],APP_EVENTS:[\"run\",\"unload\",\"lookup-route\",\"run-route\",\"route-found\",\"event-context-before\",\"event-context-after\",\"changed\",\"error\",\"check-form-submission\",\"redirect\",\"location-changed\"],_last_route:null,_location_proxy:null,_running:!1,element_selector:\"body\",debug:!1,raise_errors:!1,run_interval_every:50,disable_push_state:!1,template_engine:null,toString:function(){return\"Sammy.Application:\"+this.element_selector},$element:function(t){return t?e(this.element_selector).find(t):e(this.element_selector)},use:function(){var e=o(arguments),t=e.shift(),r=t||\"\";try{e.unshift(this),typeof t==\"string\"&&(r=\"Sammy.\"+t,t=n[t]),t.apply(this,e)}catch(i){typeof t==\"undefined\"?this.error(\"Plugin Error: called use() but plugin (\"+r.toString()+\") is not defined\",i):u(t)?this.error(\"Plugin Error\",i):this.error(\"Plugin Error: called use() but '\"+r.toString()+\"' is not a function\",i)}return this},setLocationProxy:function(e){var t=this._location_proxy;this._location_proxy=e,this.isRunning()&&(t&&t.unbind(),this._location_proxy.bind())},log:function(){n.log.apply(n,Array.prototype.concat.apply([this.element_selector],arguments))},route:function(t,n,s){var o=this,a=[],f,l;!s&&u(n)&&(n=t,s=n,t=\"any\"),t=t.toLowerCase();if(n.constructor==String){i.lastIndex=0;while((l=i.exec(n))!==null)a.push(l[1]);n=new RegExp(n.replace(i,r)+\"$\")}return typeof s==\"string\"&&(s=o[s]),f=function(e){var t={verb:e,path:n,callback:s,param_names:a};o.routes[e]=o.routes[e]||[],o.routes[e].push(t)},t===\"any\"?e.each(this.ROUTE_VERBS,function(e,t){f(t)}):f(t),this},get:p(\"get\"),post:p(\"post\"),put:p(\"put\"),del:p(\"delete\"),any:p(\"any\"),mapRoutes:function(t){var n=this;return e.each(t,function(e,t){n.route.apply(n,t)}),this},eventNamespace:function(){return[\"sammy-app\",this.namespace].join(\"-\")},bind:function(e,t,n){var r=this;typeof n==\"undefined\"&&(n=t);var i=function(){var e,t,i;e=arguments[0],i=arguments[1],i&&i.context?(t=i.context,delete i.context):t=new r.context_prototype(r,\"bind\",e.type,i,e.target),e.cleaned_type=e.type.replace(r.eventNamespace(),\"\"),n.apply(t,[e,i])};return this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(i),this.isRunning()&&this._listen(e,i),this},trigger:function(e,t){return this.$element().trigger([e,this.eventNamespace()].join(\".\"),[t]),this},refresh:function(){return this.last_location=null,this.trigger(\"location-changed\"),this},before:function(e,t){return u(e)&&(t=e,e={}),this.befores.push([e,t]),this},after:function(e){return this.bind(\"event-context-after\",e)},around:function(e){return this.arounds.push(e),this},isRunning:function(){return this._running},helpers:function(t){return e.extend(this.context_prototype.prototype,t),this},helper:function(e,t){return this.context_prototype.prototype[e]=t,this},run:function(n){if(this.isRunning())return!1;var r=this;return e.each(this.listeners.toHash(),function(t,n){e.each(n,function(e,n){r._listen(t,n)})}),this.trigger(\"run\",{start_url:n}),this._running=!0,this.last_location=null,!/\\#(.+)/.test(this.getLocation())&&typeof n!=\"undefined\"&&this.setLocation(n),this._checkLocation(),this._location_proxy.bind(),this.bind(\"location-changed\",function(){r._checkLocation()}),this.bind(\"submit\",function(t){var n=r._checkFormSubmission(e(t.target).closest(\"form\"));return n===!1?t.preventDefault():!1}),e(t).bind(\"unload\",function(){r.unload()}),this.trigger(\"changed\")},unload:function(){if(!this.isRunning())return!1;var t=this;return this.trigger(\"unload\"),this._location_proxy.unbind(),this.$element().unbind(\"submit\").removeClass(t.eventNamespace()),e.each(this.listeners.toHash(),function(n,r){e.each(r,function(e,r){t._unlisten(n,r)})}),this._running=!1,this},destroy:function(){return this.unload(),delete n.apps[this.element_selector],this},bindToAllEvents:function(t){var n=this;return e.each(this.APP_EVENTS,function(e,r){n.bind(r,t)}),e.each(this.listeners.keys(!0),function(r,i){e.inArray(i,n.APP_EVENTS)==-1&&n.bind(i,t)}),this},routablePath:function(e){return e.replace(s,\"\")},lookupRoute:function(e,t){var n=this,r=!1,i=0,s,o;if(typeof this.routes[e]!=\"undefined\"){s=this.routes[e].length;for(;i<s;i++){o=this.routes[e][i];if(n.routablePath(t).match(o.path)){r=o;break}}}return r},runRoute:function(t,n,r,i){var s=this,o=this.lookupRoute(t,n),u,a,f,c,h,p,d,v,m;this.log(\"runRoute\",[t,n].join(\" \")),this.trigger(\"run-route\",{verb:t,path:n,params:r}),typeof r==\"undefined\"&&(r={}),e.extend(r,this._parseQueryString(n));if(o){this.trigger(\"route-found\",{route:o}),(v=o.path.exec(this.routablePath(n)))!==null&&(v.shift(),e.each(v,function(e,t){o.param_names[e]?r[o.param_names[e]]=l(t):(r.splat||(r.splat=[]),r.splat.push(l(t)))})),u=new this.context_prototype(this,t,n,r,i),f=this.arounds.slice(0),h=this.befores.slice(0),d=[u].concat(r.splat),a=function(){var e;while(h.length>0){p=h.shift();if(s.contextMatchesOptions(u,p[0])){e=p[1].apply(u,[u]);if(e===!1)return!1}}return s.last_route=o,u.trigger(\"event-context-before\",{context:u}),e=o.callback.apply(u,d),u.trigger(\"event-context-after\",{context:u}),e},e.each(f.reverse(),function(e,t){var n=a;a=function(){return t.apply(u,[n])}});try{m=a()}catch(g){this.error([\"500 Error\",t,n].join(\" \"),g)}return m}return this.notFound(t,n)},contextMatchesOptions:function(t,n,r){var i=n;if(typeof i==\"string\"||f(i))i={path:i};typeof r==\"undefined\"&&(r=!0);if(e.isEmptyObject(i))return!0;if(a(i.path)){var s,o,u,l;s=[];for(o=0,l=i.path.length;o<l;o+=1)u=e.extend({},i,{path:i.path[o]}),s.push(this.contextMatchesOptions(t,u));var c=e.inArray(!0,s)>-1?!0:!1;return r?c:!c}if(i.only)return this.contextMatchesOptions(t,i.only,!0);if(i.except)return this.contextMatchesOptions(t,i.except,!1);var h=!0,p=!0;return i.path&&(f(i.path)||(i.path=new RegExp(i.path.toString()+\"$\")),h=i.path.test(t.path)),i.verb&&(typeof i.verb==\"string\"?p=i.verb===t.verb:p=i.verb.indexOf(t.verb)>-1),r?p&&h:!p||!h},getLocation:function(){return this._location_proxy.getLocation()},setLocation:function(e){return this._location_proxy.setLocation(e)},swap:function(e,t){var n=this.$element().html(e);return u(t)&&t(e),n},templateCache:function(e,t){return typeof t!=\"undefined\"?d[e]=t:d[e]},clearTemplateCache:function(){return d={}},notFound:function(e,t){var n=this.error([\"404 Not Found\",e,t].join(\" \"));return e===\"get\"?n:!0},error:function(e,t){t||(t=new Error),t.message=[e,t.message].join(\" \"),this.trigger(\"error\",{message:t.message,error:t});if(this.raise_errors)throw t;this.log(t.message,t)},_checkLocation:function(){var e,t;e=this.getLocation();if(!this.last_location||this.last_location[0]!=\"get\"||this.last_location[1]!=e)this.last_location=[\"get\",e],t=this.runRoute(\"get\",e);return t},_getFormVerb:function(t){var n=e(t),r,i;i=n.find('input[name=\"_method\"]'),i.length>0&&(r=i.val()),r||(r=n[0].getAttribute(\"method\"));if(!r||r===\"\")r=\"get\";return e.trim(r.toString().toLowerCase())},_checkFormSubmission:function(t){var n,r,i,s,o;return this.trigger(\"check-form-submission\",{form:t}),n=e(t),r=n.attr(\"action\")||\"\",i=this._getFormVerb(n),this.log(\"_checkFormSubmission\",n,r,i),i===\"get\"?(s=this._serializeFormParams(n),s!==\"\"&&(r+=\"?\"+s),this.setLocation(r),o=!1):(s=e.extend({},this._parseFormParams(n)),o=this.runRoute(i,r,s,t.get(0))),typeof o==\"undefined\"?!1:o},_serializeFormParams:function(e){var t=\"\",n=e.serializeArray(),r;if(n.length>0){t=this._encodeFormPair(n[0].name,n[0].value);for(r=1;r<n.length;r++)t=t+\"&\"+this._encodeFormPair(n[r].name,n[r].value)}return t},_encodeFormPair:function(e,t){return c(e)+\"=\"+c(t)},_parseFormParams:function(e){var t={},n=e.serializeArray(),r;for(r=0;r<n.length;r++)t=this._parseParamPair(t,n[r].name,n[r].value);return t},_parseQueryString:function(e){var t={},n,r,i,o;n=e.match(s);if(n&&n[1]){r=n[1].split(\"&\");for(o=0;o<r.length;o++)i=r[o].split(\"=\"),t=this._parseParamPair(t,l(i[0]),l(i[1]||\"\"))}return t},_parseParamPair:function(e,t,n){return typeof e[t]!=\"undefined\"?a(e[t])?e[t].push(n):e[t]=[e[t],n]:e[t]=n,e},_listen:function(e,t){return this.$element().bind([e,this.eventNamespace()].join(\".\"),t)},_unlisten:function(e,t){return this.$element().unbind([e,this.eventNamespace()].join(\".\"),t)}}),n.RenderContext=function(e){this.event_context=e,this.callbacks=[],this.previous_content=null,this.content=null,this.next_engine=!1,this.waiting=!1},n.RenderContext.prototype=e.extend({},n.Object.prototype,{then:function(e){if(!u(e)){if(!(typeof e==\"string\"&&e in this.event_context))return this;var n=this.event_context[e];e=function(e){return n.apply(this.event_context,[e])}}var r=this;return this.waiting?this.callbacks.push(e):(this.wait(),t.setTimeout(function(){var t=e.apply(r,[r.content,r.previous_content]);t!==!1&&r.next(t)},0)),this},wait:function(){this.waiting=!0},next:function(e){this.waiting=!1,typeof e!=\"undefined\"&&(this.previous_content=this.content,this.content=e),this.callbacks.length>0&&this.then(this.callbacks.shift())},load:function(t,n,r){var i=this;return this.then(function(){var s,o,a,f;u(n)?(r=n,n={}):n=e.extend({},n),r&&this.then(r);if(typeof t==\"string\")return a=t.match(/\\.json$/)||n.json,s=a?n.cache===!0:n.cache!==!1,i.next_engine=i.event_context.engineFor(t),delete n.cache,delete n.json,n.engine&&(i.next_engine=n.engine,delete n.engine),s&&(o=this.event_context.app.templateCache(t))?o:(this.wait(),e.ajax(e.extend({url:t,data:{},dataType:a?\"json\":\"text\",type:\"get\",success:function(e){s&&i.event_context.app.templateCache(t,e),i.next(e)}},n)),!1);if(t.nodeType)return t.innerHTML;if(t.selector)return i.next_engine=t.attr(\"data-engine\"),n.clone===!1?t.remove()[0].innerHTML.toString():t[0].innerHTML.toString()})},loadPartials:function(e){var t;if(e){this.partials=this.partials||{};for(t in e)(function(t,n){t.load(e[n]).then(function(e){this.partials[n]=e})})(this,t)}return this},render:function(e,t,n,r){return u(e)&&!t?this.then(e):(u(t)?(r=n,n=t,t=null):n&&!u(n)&&(r=n,n=null),this.loadPartials(r).load(e).interpolate(t,e).then(n))},partial:function(e,t,n,r){return u(n)?this.render(e,t,r).swap(n):u(t)?this.render(e,{},n).swap(t):this.render(e,t,n).swap()},send:function(){var e=this,t=o(arguments),n=t.shift();return a(t[0])&&(t=t[0]),this.then(function(r){return t.push(function(t){e.next(t)}),e.wait(),n.apply(n,t),!1})},collect:function(t,n,r){var i=this,s=function(){u(t)&&(n=t,t=this.content);var r=[],s=!1;return e.each(t,function(e,t){var o=n.apply(i,[e,t]);return o.jquery&&o.length==1&&(o=o[0],s=!0),r.push(o),o}),s?r:r.join(\"\")};return r?s():this.then(s)},renderEach:function(t,n,r,i){return a(n)&&(i=r,r=n,n=null),this.load(t).then(function(s){var o=this;r||(r=a(this.previous_content)?this.previous_content:[]);if(!i)return this.collect(r,function(e,r){var i={},o=this.next_engine||t;return n?i[n]=r:i=r,this.event_context.interpolate(s,i,o)},!0);e.each(r,function(e,r){var u={},a=this.next_engine||t;n?u[n]=r:u=r,i(r,o.event_context.interpolate(s,u,a))})})},interpolate:function(e,t,n){var r=this;return this.then(function(i,s){!e&&s&&(e=s),this.next_engine&&(t=this.next_engine,this.next_engine=!1);var o=r.event_context.interpolate(i,e,t,this.partials);return n?s+o:o})},swap:function(e){return this.then(function(t){return this.event_context.swap(t,e),t}).trigger(\"changed\",{})},appendTo:function(t){return this.then(function(n){e(t).append(n)}).trigger(\"changed\",{})},prependTo:function(t){return this.then(function(n){e(t).prepend(n)}).trigger(\"changed\",{})},replace:function(t){return this.then(function(n){e(t).html(n)}).trigger(\"changed\",{})},trigger:function(e,t){return this.then(function(n){return typeof t==\"undefined\"&&(t={content:n}),this.event_context.trigger(e,t),n})}}),n.EventContext=function(e,t,r,i,s){this.app=e,this.verb=t,this.path=r,this.params=new n.Object(i),this.target=s},n.EventContext.prototype=e.extend({},n.Object.prototype,{$element:function(){return this.app.$element(o(arguments).shift())},engineFor:function(e){var t=this,n;if(u(e))return e;e=(e||t.app.template_engine).toString();if(n=e.match(/\\.([^\\.\\?\\#]+)$/))e=n[1];return e&&u(t[e])?t[e]:t.app.template_engine?this.engineFor(t.app.template_engine):function(e,t){return e}},interpolate:function(e,t,n,r){return this.engineFor(n).apply(this,[e,t,r])},render:function(e,t,r,i){return(new n.RenderContext(this)).render(e,t,r,i)},renderEach:function(e,t,r,i){return(new n.RenderContext(this)).renderEach(e,t,r,i)},load:function(e,t,r){return(new n.RenderContext(this)).load(e,t,r)},loadPartials:function(e){return(new n.RenderContext(this)).loadPartials(e)},partial:function(e,t,r,i){return(new n.RenderContext(this)).partial(e,t,r,i)},send:function(){var e=new n.RenderContext(this);return e.send.apply(e,arguments)},redirect:function(){var t,n=o(arguments),r=this.app.getLocation(),i=n.length;if(i>1){var s=0,u=[],a=[],f={},l=!1;for(;s<i;s++)typeof n[s]==\"string\"?u.push(n[s]):(e.extend(f,n[s]),l=!0);t=u.join(\"/\");if(l){for(var c in f)a.push(this.app._encodeFormPair(c,f[c]));t+=\"?\"+a.join(\"&\")}}else t=n[0];this.trigger(\"redirect\",{to:t}),this.app.last_location=[this.verb,this.path],this.app.setLocation(t),(new RegExp(t)).test(r)&&this.app.trigger(\"location-changed\")},trigger:function(e,t){return typeof t==\"undefined\"&&(t={}),t.context||(t.context=this),this.app.trigger(e,t)},eventNamespace:function(){return this.app.eventNamespace()},swap:function(e,t){return this.app.swap(e,t)},notFound:function(){return this.app.notFound(this.verb,this.path)},json:function(t){return e.parseJSON(t)},toString:function(){return\"Sammy.EventContext: \"+[this.verb,this.path,this.params].join(\" \")}}),n})})(jQuery,window);\r\n"]],"start1":0,"start2":0,"length1":0,"length2":18536}]],"length":18536,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351696481468,"patch":[[{"diffs":[[-1,"// -- Sammy.js -- /sammy.js\r\n// http://sammyjs.org\r\n// Version: 0.7.2\r\n// Built: 2012-10-19 23:50:30 -0400\r\n"],[0,"// n"]],"start1":0,"start2":0,"length1":112,"length2":4},{"diffs":[[0," sammy\r\n"],[1,""],[0,"// versi"]],"start1":8,"start2":8,"length1":16,"length2":16},{"diffs":[[0," 0.7.2\r\n"],[1,"\r\n"],[0,"// Sammy"]],"start1":27,"start2":27,"length1":16,"length2":18},{"diffs":[[0,"rg\r\n"],[-1,"(function(e,t){(function(n){typeof define==\"function\"&&define.amd?define([\"jquery\"],n):e.sammy=t.Sammy=n(e)})(function(e){var n,r=\"([^/]+)\",i=/:([\\w\\d]+)/g,s=/\\?([^#]*)?$/,o=function(e){return Array.prototype.slice.call(e)},u=function(e){return Object.prototype.toString.call(e)===\"[object Function]\"},a=function(e){return Object.prototype.toString.call(e)===\"[object Array]\"},f=function(e){return Object.prototype.toString.call(e)===\"[object RegExp]\"},l=function(e){return decodeURIComponent((e||\"\").replace(/\\+/g,\" \"))},c=encodeURIComponent,h=function(e){return String(e).replace(/&(?!\\w+;)/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\").replace(/\"/g,\"&quot;\")},p=function(e){return function(t,n){return this.route.apply(this,[e,t,n])}},d={},v=!!t.history&&!!history.pushState,m=[];return n=function(){var t=o(arguments),r,i;n.apps=n.apps||{};if(t.length===0||t[0]&&u(t[0]))return n.apply(n,[\"body\"].concat(t));if(typeof (i=t.shift())==\"string\")return r=n.apps[i]||new n.Application,r.element_selector=i,t.length>0&&e.each(t,function(e,t){r.use(t)}),r.element_selector!=i&&delete n.apps[i],n.apps[r.element_selector]=r,r},n.VERSION=\"0.7.2\",n.addLogger=function(e){m.push(e)},n.log=function(){var t=o(arguments);t.unshift(\"[\"+Date()+\"]\"),e.each(m,function(e,r){r.apply(n,t)})},typeof t.console!=\"undefined\"?u(t.console.log.apply)?n.addLogger(function(){t.console.log.apply(t.console,arguments)}):n.addLogger(function(){t.console.log(arguments)}):typeof console!=\"undefined\"&&n.addLogger(function(){console.log.apply(console,arguments)}),e.extend(n,{makeArray:o,isFunction:u,isArray:a}),n.Object=function(t){return e.extend(this,t||{})},e.extend(n.Object.prototype,{escapeHTML:h,h:h,toHash:function(){var t={};return e.each(this,function(e,n){u(n)||(t[e]=n)}),t},toHTML:function(){var t=\"\";return e.each(this,function(e,n){u(n)||(t+=\"<strong>\"+e+\"</strong> \"+n+\"<br />\")}),t},keys:function(e){var t=[];for(var n in this)(!u(this[n])||!e)&&t.push(n);return t},has:function(t){return this[t]&&e.trim(this[t].toString())!==\"\"},join:function(){var e=o(arguments),t=e.shift();return e.join(t)},log:function(){n.log.apply(n,arguments)},toString:function(t){var n=[];return e.each(this,function(e,r){(!u(r)||t)&&n.push('\"'+e+'\": '+r.toString())}),\"Sammy.Object: {\"+n.join(\",\")+\"}\"}}),n.DefaultLocationProxy=function(e,t){this.app=e,this.is_native=!1,this.has_history=v,this._startPolling(t)},n.DefaultLocationProxy.fullPath=function(e){var t=e.toString().match(/^[^#]*(#.+)$/),n=t?t[1]:\"\";return[e.pathname,e.search,n].join(\"\")},e.extend(n.DefaultLocationProxy.prototype,{bind:function(){var r=this,i=this.app,s=n.DefaultLocationProxy;e(t).bind(\"hashchange.\"+this.app.eventNamespace(),function(e,n){r.is_native===!1&&!n&&(r.is_native=!0,t.clearInterval(s._interval)),i.trigger(\"location-changed\")}),v&&!i.disable_push_state&&(e(t).bind(\"popstate.\"+this.app.eventNamespace(),function(e){i.trigger(\"location-changed\")}),e(\"a\").live(\"click.history-\"+this.app.eventNamespace(),function(e){if(e.isDefaultPrevented()||e.metaKey||e.ctrlKey)return;var n=s.fullPath(this);if(this.hostname==t.location.hostname&&i.lookupRoute(\"get\",n)&&this.target!==\"_blank\")return e.preventDefault(),r.setLocation(n),!1})),s._bindings||(s._bindings=0),s._bindings++},unbind:function(){e(t).unbind(\"hashchange.\"+this.app.eventNamespace()),e(t).unbind(\"popstate.\"+this.app.eventNamespace()),e(\"a\").die(\"click.history-\"+this.app.eventNamespace()),n.DefaultLocationProxy._bindings--,n.DefaultLocationProxy._bindings<=0&&t.clearInterval(n.DefaultLocationProxy._interval)},getLocation:function(){return n.DefaultLocationProxy.fullPath(t.location)},setLocation:function(e){/^([^#\\/]|$)/.test(e)&&(v&&!this.app.disable_push_state?e=\"/\"+e:e=\"#!/\"+e);if(e!=this.getLocation()){if(!(v&&!this.app.disable_push_state&&/^\\//.test(e)))return t.location=e;history.pushState({path:e},t.title,e),this.app.trigger(\"location-changed\")}},_startPolling:function(r){var i=this;if(!n.DefaultLocationProxy._interval){r||(r=10);var s=function(){var r=i.getLocation();(typeof n.DefaultLocationProxy._last_location==\"undefined\"||r!=n.DefaultLocationProxy._last_location)&&t.setTimeout(function(){e(t).trigger(\"hashchange\",[!0])},0),n.DefaultLocationProxy._last_location=r};s(),n.DefaultLocationProxy._interval=t.setInterval(s,r)}}}),n.Application=function(e){var t=this;this.routes={},this.listeners=new n.Object({}),this.arounds=[],this.befores=[],this.namespace=(new Date).getTime()+\"-\"+parseInt(Math.random()*1e3,10),this.context_prototype=function(){n.EventContext.apply(this,arguments)},this.context_prototype.prototype=new n.EventContext,u(e)&&e.apply(this,[this]),this._location_proxy||this.setLocationProxy(new n.DefaultLocationProxy(this,this.run_interval_every)),this.debug&&this.bindToAllEvents(function(e,n){t.log(t.toString(),e.cleaned_type,n||{})})},n.Application.prototype=e.extend({},n.Object.prototype,{ROUTE_VERBS:[\"get\",\"post\",\"put\",\"delete\"],APP_EVENTS:[\"run\",\"unload\",\"lookup-route\",\"run-route\",\"route-found\",\"event-context-before\",\"event-context-after\",\"changed\",\"error\",\"check-form-submission\",\"redirect\",\"location-changed\"],_last_route:null,_location_proxy:null,_running:!1,element_selector:\"body\",debug:!1,raise_errors:!1,run_interval_every:50,disable_push_state:!1,template_engine:null,toString:function(){return\"Sammy.Application:\"+this.element_selector},$element:function(t){return t?e(this.element_selector).find(t):e(this.element_selector)},use:function(){var e=o(arguments),t=e.shift(),r=t||\"\";try{e.unshift(this),typeof t==\"string\"&&(r=\"Sammy.\"+t,t=n[t]),t.apply(this,e)}catch(i){typeof t==\"undefined\"?this.error(\"Plugin Error: called use() but plugin (\"+r.toString()+\") is not defined\",i):u(t)?this.error(\"Plugin Error\",i):this.error(\"Plugin Error: called use() but '\"+r.toString()+\"' is not a function\",i)}return this},setLocationProxy:function(e){var t=this._location_proxy;this._location_proxy=e,this.isRunning()&&(t&&t.unbind(),this._location_proxy.bind())},log:function(){n.log.apply(n,Array.prototype.concat.apply([this.element_selector],arguments))},route:function(t,n,s){var o=this,a=[],f,l;!s&&u(n)&&(n=t,s=n,t=\"any\"),t=t.toLowerCase();if(n.constructor==String){i.lastIndex=0;while((l=i.exec(n))!==null)a.push(l[1]);n=new RegExp(n.replace(i,r)+\"$\")}return typeof s==\"string\"&&(s=o[s]),f=function(e){var t={verb:e,path:n,callback:s,param_names:a};o.routes[e]=o.routes[e]||[],o.routes[e].push(t)},t===\"any\"?e.each(this.ROUTE_VERBS,function(e,t){f(t)}):f(t),this},get:p(\"get\"),post:p(\"post\"),put:p(\"put\"),del:p(\"delete\"),any:p(\"any\"),mapRoutes:function(t){var n=this;return e.each(t,function(e,t){n.route.apply(n,t)}),this},eventNamespace:function(){return[\"sammy-app\",this.namespace].join(\"-\")},bind:function(e,t,n){var r=this;typeof n==\"undefined\"&&(n=t);var i=function(){var e,t,i;e=arguments[0],i=arguments[1],i&&i.context?(t=i.context,delete i.context):t=new r.context_prototype(r,\"bind\",e.type,i,e.target),e.cleaned_type=e.type.replace(r.eventNamespace(),\"\"),n.apply(t,[e,i])};return this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(i),this.isRunning()&&this._listen(e,i),this},trigger:function(e,t){return this.$element().trigger([e,this.eventNamespace()].join(\".\"),[t]),this},refresh:function(){return this.last_location=null,this.trigger(\"location-changed\"),this},before:function(e,t){return u(e)&&(t=e,e={}),this.befores.push([e,t]),this},after:function(e){return this.bind(\"event-context-after\",e)},around:function(e){return this.arounds.push(e),this},isRunning:function(){return this._running},helpers:function(t){return e.extend(this.context_prototype.prototype,t),this},helper:function(e,t){return this.context_prototype.prototype[e]=t,this},run:function(n){if(this.isRunning())return!1;var r=this;return e.each(this.listeners.toHash(),function(t,n){e.each(n,function(e,n){r._listen(t,n)})}),this.trigger(\"run\",{start_url:n}),this._running=!0,this.last_location=null,!/\\#(.+)/.test(this.getLocation())&&typeof n!=\"undefined\"&&this.setLocation(n),this._checkLocation(),this._location_proxy.bind(),this.bind(\"location-changed\",function(){r._checkLocation()}),this.bind(\"submit\",function(t){var n=r._checkFormSubmission(e(t.target).closest(\"form\"));return n===!1?t.preventDefault():!1}),e(t).bind(\"unload\",function(){r.unload()}),this.trigger(\"changed\")},unload:function(){if(!this.isRunning())return!1;var t=this;return this.trigger(\"unload\"),this._location_proxy.unbind(),this.$element().unbind(\"submit\").removeClass(t.eventNamespace()),e.each(this.listeners.toHash(),function(n,r){e.each(r,function(e,r){t._unlisten(n,r)})}),this._running=!1,this},destroy:function(){return this.unload(),delete n.apps[this.element_selector],this},bindToAllEvents:function(t){var n=this;return e.each(this.APP_EVENTS,function(e,r){n.bind(r,t)}),e.each(this.listeners.keys(!0),function(r,i){e.inArray(i,n.APP_EVENTS)==-1&&n.bind(i,t)}),this},routablePath:function(e){return e.replace(s,\"\")},lookupRoute:function(e,t){var n=this,r=!1,i=0,s,o;if(typeof this.routes[e]!=\"undefined\"){s=this.routes[e].length;for(;i<s;i++){o=this.routes[e][i];if(n.routablePath(t).match(o.path)){r=o;break}}}return r},runRoute:function(t,n,r,i){var s=this,o=this.lookupRoute(t,n),u,a,f,c,h,p,d,v,m;this.log(\"runRoute\",[t,n].join(\" \")),this.trigger(\"run-route\",{verb:t,path:n,params:r}),typeof r==\"undefined\"&&(r={}),e.extend(r,this._parseQueryString(n));if(o){this.trigger(\"route-found\",{route:o}),(v=o.path.exec(this.routablePath(n)))!==null&&(v.shift(),e.each(v,function(e,t){o.param_names[e]?r[o.param_names[e]]=l(t):(r.splat||(r.splat=[]),r.splat.push(l(t)))})),u=new this.context_prototype(this,t,n,r,i),f=this.arounds.slice(0),h=this.befores.slice(0),d=[u].concat(r.splat),a=function(){var e;while(h.length>0){p=h.shift();if(s.contextMatchesOptions(u,p[0])){e=p[1].apply(u,[u]);if(e===!1)return!1}}return s.last_route=o,u.trigger(\"event-context-before\",{context:u}),e=o.callback.apply(u,d),u.trigger(\"event-context-after\",{context:u}),e},e.each(f.reverse(),function(e,t){var n=a;a=function(){return t.apply(u,[n])}});try{m=a()}catch(g){this.error([\"500 Error\",t,n].join(\" \"),g)}return m}return this.notFound(t,n)},contextMatchesOptions:function(t,n,r){var i=n;if(typeof i==\"string\"||f(i))i={path:i};typeof r==\"undefined\"&&(r=!0);if(e.isEmptyObject(i))return!0;if(a(i.path)){var s,o,u,l;s=[];for(o=0,l=i.path.length;o<l;o+=1)u=e.extend({},i,{path:i.path[o]}),s.push(this.contextMatchesOptions(t,u));var c=e.inArray(!0,s)>-1?!0:!1;return r?c:!c}if(i.only)return this.contextMatchesOptions(t,i.only,!0);if(i.except)return this.contextMatchesOptions(t,i.except,!1);var h=!0,p=!0;return i.path&&(f(i.path)||(i.path=new RegExp(i.path.toString()+\"$\")),h=i.path.test(t.path)),i.verb&&(typeof i.verb==\"string\"?p=i.verb===t.verb:p=i.verb.indexOf(t.verb)>-1),r?p&&h:!p||!h},getLocation:function(){return this._location_proxy.getLocation()},setLocation:function(e){return this._location_proxy.setLocation(e)},swap:function(e,t){var n=this.$element().html(e);return u(t)&&t(e),n},templateCache:function(e,t){return typeof t!=\"undefined\"?d[e]=t:d[e]},clearTemplateCache:function(){return d={}},notFound:function(e,t){var n=this.error([\"404 Not Found\",e,t].join(\" \"));return e===\"get\"?n:!0},error:function(e,t){t||(t=new Error),t.message=[e,t.message].join(\" \"),this.trigger(\"error\",{message:t.message,error:t});if(this.raise_errors)throw t;this.log(t.message,t)},_checkLocation:function(){var e,t;e=this.getLocation();if(!this.last_location||this.last_location[0]!=\"get\"||this.last_location[1]!=e)this.last_location=[\"get\",e],t=this.runRoute(\"get\",e);return t},_getFormVerb:function(t){var n=e(t),r,i;i=n.find('input[name=\"_method\"]'),i.length>0&&(r=i.val()),r||(r=n[0].getAttribute(\"method\"));if(!r||r===\"\")r=\"get\";return e.trim(r.toString().toLowerCase())},_checkFormSubmission:function(t){var n,r,i,s,o;return this.trigger(\"check-form-submission\",{form:t}),n=e(t),r=n.attr(\"action\")||\"\",i=this._getFormVerb(n),this.log(\"_checkFormSubmission\",n,r,i),i===\"get\"?(s=this._serializeFormParams(n),s!==\"\"&&(r+=\"?\"+s),this.setLocation(r),o=!1):(s=e.extend({},this._parseFormParams(n)),o=this.runRoute(i,r,s,t.get(0))),typeof o==\"undefined\"?!1:o},_serializeFormParams:function(e){var t=\"\",n=e.serializeArray(),r;if(n.length>0){t=this._encodeFormPair(n[0].name,n[0].value);for(r=1;r<n.length;r++)t=t+\"&\"+this._encodeFormPair(n[r].name,n[r].value)}return t},_encodeFormPair:function(e,t){return c(e)+\"=\"+c(t)},_parseFormParams:function(e){var t={},n=e.serializeArray(),r;for(r=0;r<n.length;r++)t=this._parseParamPair(t,n[r].name,n[r].value);return t},_parseQueryString:function(e){var t={},n,r,i,o;n=e.match(s);if(n&&n[1]){r=n[1].split(\"&\");for(o=0;o<r.length;o++)i=r[o].split(\"=\"),t=this._parseParamPair(t,l(i[0]),l(i[1]||\"\"))}return t},_parseParamPair:function(e,t,n){return typeof e[t]!=\"undefined\"?a(e[t])?e[t].push(n):e[t]=[e[t],n]:e[t]=n,e},_listen:function(e,t){return this.$element().bind([e,this.eventNamespace()].join(\".\"),t)},_unlisten:function(e,t){return this.$element().unbind([e,this.eventNamespace()].join(\".\"),t)}}),n.RenderContext=function(e){this.event_context=e,this.callbacks=[],this.previous_content=null,this.content=null,this.next_engine=!1,this.waiting=!1},n.RenderContext.prototype=e.extend({},n.Object.prototype,{then:function(e){if(!u(e)){if(!(typeof e==\"string\"&&e in this.event_context))return this;var n=this.event_context[e];e=function(e){return n.apply(this.event_context,[e])}}var r=this;return this.waiting?this.callbacks.push(e):(this.wait(),t.setTimeout(function(){var t=e.apply(r,[r.content,r.previous_content]);t!==!1&&r.next(t)},0)),this},wait:function(){this.waiting=!0},next:function(e){this.waiting=!1,typeof e!=\"undefined\"&&(this.previous_content=this.content,this.content=e),this.callbacks.length>0&&this.then(this.callbacks.shift())},load:function(t,n,r){var i=this;return this.then(function(){var s,o,a,f;u(n)?(r=n,n={}):n=e.extend({},n),r&&this.then(r);if(typeof t==\"string\")return a=t.match(/\\.json$/)||n.json,s=a?n.cache===!0:n.cache!==!1,i.next_engine=i.event_context.engineFor(t),delete n.cache,delete n.json,n.engine&&(i.next_engine=n.engine,delete n.engine),s&&(o=this.event_context.app.templateCache(t))?o:(this.wait(),e.ajax(e.extend({url:t,data:{},dataType:a?\"json\":\"text\",type:\"get\",success:function(e){s&&i.event_context.app.templateCache(t,e),i.next(e)}},n)),!1);if(t.nodeType)return t.innerHTML;if(t.selector)return i.next_engine=t.attr(\"data-engine\"),n.clone===!1?t.remove()[0].innerHTML.toString():t[0].innerHTML.toString()})},loadPartials:function(e){var t;if(e){this.partials=this.partials||{};for(t in e)(function(t,n){t.load(e[n]).then(function(e){this.partials[n]=e})})(this,t)}return this},render:function(e,t,n,r){return u(e)&&!t?this.then(e):(u(t)?(r=n,n=t,t=null):n&&!u(n)&&(r=n,n=null),this.loadPartials(r).load(e).interpolate(t,e).then(n))},partial:function(e,t,n,r){return u(n)?this.render(e,t,r).swap(n):u(t)?this.render(e,{},n).swap(t):this.render(e,t,n).swap()},send:function(){var e=this,t=o(arguments),n=t.shift();return a(t[0])&&(t=t[0]),this.then(function(r){return t.push(function(t){e.next(t)}),e.wait(),n.apply(n,t),!1})},collect:function(t,n,r){var i=this,s=function(){u(t)&&(n=t,t=this.content);var r=[],s=!1;return e.each(t,function(e,t){var o=n.apply(i,[e,t]);return o.jquery&&o.length==1&&(o=o[0],s=!0),r.push(o),o}),s?r:r.join(\"\")};return r?s():this.then(s)},renderEach:function(t,n,r,i){return a(n)&&(i=r,r=n,n=null),this.load(t).then(function(s){var o=this;r||(r=a(this.previous_content)?this.previous_content:[]);if(!i)return this.collect(r,function(e,r){var i={},o=this.next_engine||t;return n?i[n]=r:i=r,this.event_context.interpolate(s,i,o)},!0);e.each(r,function(e,r){var u={},a=this.next_engine||t;n?u[n]=r:u=r,i(r,o.event_context.interpolate(s,u,a))})})},interpolate:function(e,t,n){var r=this;return this.then(function(i,s){!e&&s&&(e=s),this.next_engine&&(t=this.next_engine,this.next_engine=!1);var o=r.event_context.interpolate(i,e,t,this.partials);return n?s+o:o})},swap:function(e){return this.then(function(t){return this.event_context.swap(t,e),t}).trigger(\"changed\",{})},appendTo:function(t){return this.then(function(n){e(t).append(n)}).trigger(\"changed\",{})},prependTo:function(t){return this.then(function(n){e(t).prepend(n)}).trigger(\"changed\",{})},replace:function(t){return this.then(function(n){e(t).html(n)}).trigger(\"changed\",{})},trigger:function(e,t){return this.then(function(n){return typeof t==\"undefined\"&&(t={content:n}),this.event_context.trigger(e,t),n})}}),n.EventContext=function(e,t,r,i,s){this.app=e,this.verb=t,this.path=r,this.params=new n.Object(i),this.target=s},n.EventContext.prototype=e.extend({},n.Object.prototype,{$element:function(){return this.app.$element(o(arguments).shift())},engineFor:function(e){var t=this,n;if(u(e))return e;e=(e||t.app.template_engine).toString();if(n=e.match(/\\.([^\\.\\?\\#]+)$/))e=n[1];return e&&u(t[e])?t[e]:t.app.template_engine?this.engineFor(t.app.template_engine):function(e,t){return e}},interpolate:function(e,t,n,r){return this.engineFor(n).apply(this,[e,t,r])},render:function(e,t,r,i){return(new n.RenderContext(this)).render(e,t,r,i)},renderEach:function(e,t,r,i){return(new n.RenderContext(this)).renderEach(e,t,r,i)},load:function(e,t,r){return(new n.RenderContext(this)).load(e,t,r)},loadPartials:function(e){return(new n.RenderContext(this)).loadPartials(e)},partial:function(e,t,r,i){return(new n.RenderContext(this)).partial(e,t,r,i)},send:function(){var e=new n.RenderContext(this);return e.send.apply(e,arguments)},redirect:function(){var t,n=o(arguments),r=this.app.getLocation(),i=n.length;if(i>1){var s=0,u=[],a=[],f={},l=!1;for(;s<i;s++)typeof n[s]==\"string\"?u.push(n[s]):(e.extend(f,n[s]),l=!0);t=u.join(\"/\");if(l){for(var c in f)a.push(this.app._encodeFormPair(c,f[c]));t+=\"?\"+a.join(\"&\")}}else t=n[0];this.trigger(\"redirect\",{to:t}),this.app.last_location=[this.verb,this.path],this.app.setLocation(t),(new RegExp(t)).test(r)&&this.app.trigger(\"location-changed\")},trigger:function(e,t){return typeof t==\"undefined\"&&(t={}),t.context||(t.context=this),this.app.trigger(e,t)},eventNamespace:function(){return this.app.eventNamespace()},swap:function(e,t){return this.app.swap(e,t)},notFound:function(){return this.app.notFound(this.verb,this.path)},json:function(t){return e.parseJSON(t)},toString:function(){return\"Sammy.EventContext: \"+[this.verb,this.path,this.params].join(\" \")}}),n})})(jQuery,window);\r\n"],[1,"\r\n(function($, window) {\r\n  (function(factory){\r\n    // Support module loading scenarios\r\n    if (typeof define === 'function' && define.amd){\r\n      // AMD Anonymous Module\r\n      define(['jquery'], factory);\r\n    } else {\r\n      // No module loader (plain <script> tag) - put directly in global namespace\r\n      $.sammy = window.Sammy = factory($);\r\n    }\r\n  })(function($){\r\n\r\n  var Sammy,\r\n      PATH_REPLACER = \"([^\\/]+)\",\r\n      PATH_NAME_MATCHER = /:([\\w\\d]+)/g,\r\n      QUERY_STRING_MATCHER = /\\?([^#]*)?$/,\r\n      // mainly for making `arguments` an Array\r\n      _makeArray = function(nonarray) { return Array.prototype.slice.call(nonarray); },\r\n      // borrowed from jQuery\r\n      _isFunction = function( obj ) { return Object.prototype.toString.call(obj) === \"[object Function]\"; },\r\n      _isArray = function( obj ) { return Object.prototype.toString.call(obj) === \"[object Array]\"; },\r\n      _isRegExp = function( obj ) { return Object.prototype.toString.call(obj) === \"[object RegExp]\"; },\r\n      _decode = function( str ) { return decodeURIComponent((str || '').replace(/\\+/g, ' ')); },\r\n      _encode = encodeURIComponent,\r\n      _escapeHTML = function(s) {\r\n        return String(s).replace(/&(?!\\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\r\n      },\r\n      _routeWrapper = function(verb) {\r\n        return function(path, callback) { return this.route.apply(this, [verb, path, callback]); };\r\n      },\r\n      _template_cache = {},\r\n      _has_history = !!(window.history && history.pushState),\r\n      loggers = [];\r\n\r\n\r\n  // `Sammy` (also aliased as $.sammy) is not only the namespace for a\r\n  // number of prototypes, its also a top level method that allows for easy\r\n  // creation/management of `Sammy.Application` instances. There are a\r\n  // number of different forms for `Sammy()` but each returns an instance\r\n  // of `Sammy.Application`. When a new instance is created using\r\n  // `Sammy` it is added to an Object called `Sammy.apps`. This\r\n  // provides for an easy way to get at existing Sammy applications. Only one\r\n  // instance is allowed per `element_selector` so when calling\r\n  // `Sammy('selector')` multiple times, the first time will create\r\n  // the application and the following times will extend the application\r\n  // already added to that selector.\r\n  //\r\n  // ### Example\r\n  //\r\n  //      // returns the app at #main or a new app\r\n  //      Sammy('#main')\r\n  //\r\n  //      // equivalent to \"new Sammy.Application\", except appends to apps\r\n  //      Sammy();\r\n  //      Sammy(function() { ... });\r\n  //\r\n  //      // extends the app at '#main' with function.\r\n  //      Sammy('#main', function() { ... });\r\n  //\r\n  Sammy = function() {\r\n    var args = _makeArray(arguments),\r\n        app, selector;\r\n    Sammy.apps = Sammy.apps || {};\r\n    if (args.length === 0 || args[0] && _isFunction(args[0])) { // Sammy()\r\n      return Sammy.apply(Sammy, ['body'].concat(args));\r\n    } else if (typeof (selector = args.shift()) == 'string') { // Sammy('#main')\r\n      app = Sammy.apps[selector] || new Sammy.Application();\r\n      app.element_selector = selector;\r\n      if (args.length > 0) {\r\n        $.each(args, function(i, plugin) {\r\n          app.use(plugin);\r\n        });\r\n      }\r\n      // if the selector changes make sure the reference in Sammy.apps changes\r\n      if (app.element_selector != selector) {\r\n        delete Sammy.apps[selector];\r\n      }\r\n      Sammy.apps[app.element_selector] = app;\r\n      return app;\r\n    }\r\n  };\r\n\r\n  Sammy.VERSION = '0.7.2';\r\n\r\n  // Add to the global logger pool. Takes a function that accepts an\r\n  // unknown number of arguments and should print them or send them somewhere\r\n  // The first argument is always a timestamp.\r\n  Sammy.addLogger = function(logger) {\r\n    loggers.push(logger);\r\n  };\r\n\r\n  // Sends a log message to each logger listed in the global\r\n  // loggers pool. Can take any number of arguments.\r\n  // Also prefixes the arguments with a timestamp.\r\n  Sammy.log = function()  {\r\n    var args = _makeArray(arguments);\r\n    args.unshift(\"[\" + Date() + \"]\");\r\n    $.each(loggers, function(i, logger) {\r\n      logger.apply(Sammy, args);\r\n    });\r\n  };\r\n\r\n  if (typeof window.console != 'undefined') {\r\n    if (_isFunction(window.console.log.apply)) {\r\n      Sammy.addLogger(function() {\r\n        window.console.log.apply(window.console, arguments);\r\n      });\r\n    } else {\r\n      Sammy.addLogger(function() {\r\n        window.console.log(arguments);\r\n      });\r\n    }\r\n  } else if (typeof console != 'undefined') {\r\n    Sammy.addLogger(function() {\r\n      console.log.apply(console, arguments);\r\n    });\r\n  }\r\n\r\n  $.extend(Sammy, {\r\n    makeArray: _makeArray,\r\n    isFunction: _isFunction,\r\n    isArray: _isArray\r\n  });\r\n\r\n  // Sammy.Object is the base for all other Sammy classes. It provides some useful\r\n  // functionality, including cloning, iterating, etc.\r\n  Sammy.Object = function(obj) { // constructor\r\n    return $.extend(this, obj || {});\r\n  };\r\n\r\n  $.extend(Sammy.Object.prototype, {\r\n\r\n    // Escape HTML in string, use in templates to prevent script injection.\r\n    // Also aliased as `h()`\r\n    escapeHTML: _escapeHTML,\r\n    h: _escapeHTML,\r\n\r\n    // Returns a copy of the object with Functions removed.\r\n    toHash: function() {\r\n      var json = {};\r\n      $.each(this, function(k,v) {\r\n        if (!_isFunction(v)) {\r\n          json[k] = v;\r\n        }\r\n      });\r\n      return json;\r\n    },\r\n\r\n    // Renders a simple HTML version of this Objects attributes.\r\n    // Does not render functions.\r\n    // For example. Given this Sammy.Object:\r\n    //\r\n    //     var s = new Sammy.Object({first_name: 'Sammy', last_name: 'Davis Jr.'});\r\n    //     s.toHTML()\r\n    //     //=> '<strong>first_name</strong> Sammy<br /><strong>last_name</strong> Davis Jr.<br />'\r\n    //\r\n    toHTML: function() {\r\n      var display = \"\";\r\n      $.each(this, function(k, v) {\r\n        if (!_isFunction(v)) {\r\n          display += \"<strong>\" + k + \"</strong> \" + v + \"<br />\";\r\n        }\r\n      });\r\n      return display;\r\n    },\r\n\r\n    // Returns an array of keys for this object. If `attributes_only`\r\n    // is true will not return keys that map to a `function()`\r\n    keys: function(attributes_only) {\r\n      var keys = [];\r\n      for (var property in this) {\r\n        if (!_isFunction(this[property]) || !attributes_only) {\r\n          keys.push(property);\r\n        }\r\n      }\r\n      return keys;\r\n    },\r\n\r\n    // Checks if the object has a value at `key` and that the value is not empty\r\n    has: function(key) {\r\n      return this[key] && $.trim(this[key].toString()) !== '';\r\n    },\r\n\r\n    // convenience method to join as many arguments as you want\r\n    // by the first argument - useful for making paths\r\n    join: function() {\r\n      var args = _makeArray(arguments);\r\n      var delimiter = args.shift();\r\n      return args.join(delimiter);\r\n    },\r\n\r\n    // Shortcut to Sammy.log\r\n    log: function() {\r\n      Sammy.log.apply(Sammy, arguments);\r\n    },\r\n\r\n    // Returns a string representation of this object.\r\n    // if `include_functions` is true, it will also toString() the\r\n    // methods of this object. By default only prints the attributes.\r\n    toString: function(include_functions) {\r\n      var s = [];\r\n      $.each(this, function(k, v) {\r\n        if (!_isFunction(v) || include_functions) {\r\n          s.push('\"' + k + '\": ' + v.toString());\r\n        }\r\n      });\r\n      return \"Sammy.Object: {\" + s.join(',') + \"}\";\r\n    }\r\n  });\r\n\r\n  // The DefaultLocationProxy is the default location proxy for all Sammy applications.\r\n  // A location proxy is a prototype that conforms to a simple interface. The purpose\r\n  // of a location proxy is to notify the Sammy.Application its bound to when the location\r\n  // or 'external state' changes.\r\n  //\r\n  // The `DefaultLocationProxy` watches for changes to the path of the current window and\r\n  // is also able to set the path based on changes in the application. It does this by\r\n  // using different methods depending on what is available in the current browser. In\r\n  // the latest and greatest browsers it used the HTML5 History API and the `pushState`\r\n  // `popState` events/methods. This allows you to use Sammy to serve a site behind normal\r\n  // URI paths as opposed to the older default of hash (#) based routing. Because the server\r\n  // can interpret the changed path on a refresh or re-entry, though, it requires additional\r\n  // support on the server side. If you'd like to force disable HTML5 history support, please\r\n  // use the `disable_push_state` setting on `Sammy.Application`. If pushState support\r\n  // is enabled, `DefaultLocationProxy` also binds to all links on the page. If a link is clicked\r\n  // that matches the current set of routes, the URL is changed using pushState instead of\r\n  // fully setting the location and the app is notified of the change.\r\n  //\r\n  // If the browser does not have support for HTML5 History, `DefaultLocationProxy` automatically\r\n  // falls back to the older hash based routing. The newest browsers (IE, Safari > 4, FF >= 3.6)\r\n  // support a 'onhashchange' DOM event, thats fired whenever the location.hash changes.\r\n  // In this situation the DefaultLocationProxy just binds to this event and delegates it to\r\n  // the application. In the case of older browsers a poller is set up to track changes to the\r\n  // hash.\r\n  Sammy.DefaultLocationProxy = function(app, run_interval_every) {\r\n    this.app = app;\r\n    // set is native to false and start the poller immediately\r\n    this.is_native = false;\r\n    this.has_history = _has_history;\r\n    this._startPolling(run_interval_every);\r\n  };\r\n\r\n  Sammy.DefaultLocationProxy.fullPath = function(location_obj) {\r\n   // Bypass the `window.location.hash` attribute.  If a question mark\r\n    // appears in the hash IE6 will strip it and all of the following\r\n    // characters from `window.location.hash`.\r\n    var matches = location_obj.toString().match(/^[^#]*(#.+)$/);\r\n    var hash = matches ? matches[1] : '';\r\n    return [location_obj.pathname, location_obj.search, hash].join('');\r\n  };\r\n$.extend(Sammy.DefaultLocationProxy.prototype , {\r\n    // bind the proxy events to the current app.\r\n    bind: function() {\r\n      var proxy = this, app = this.app, lp = Sammy.DefaultLocationProxy;\r\n      $(window).bind('hashchange.' + this.app.eventNamespace(), function(e, non_native) {\r\n        // if we receive a native hash change event, set the proxy accordingly\r\n        // and stop polling\r\n        if (proxy.is_native === false && !non_native) {\r\n          proxy.is_native = true;\r\n          window.clearInterval(lp._interval);\r\n        }\r\n        app.trigger('location-changed');\r\n      });\r\n      if (_has_history && !app.disable_push_state) {\r\n        // bind to popstate\r\n        $(window).bind('popstate.' + this.app.eventNamespace(), function(e) {\r\n          app.trigger('location-changed');\r\n        });\r\n        // bind to link clicks that have routes\r\n        $('a').live('click.history-' + this.app.eventNamespace(), function(e) {\r\n          if (e.isDefaultPrevented() || e.metaKey || e.ctrlKey) {\r\n            return;\r\n          }\r\n          var full_path = lp.fullPath(this);\r\n          if (this.hostname == window.location.hostname &&\r\n              app.lookupRoute('get', full_path) &&\r\n              this.target !== '_blank') {\r\n            e.preventDefault();\r\n            proxy.setLocation(full_path);\r\n            return false;\r\n          }\r\n        });\r\n      }\r\n      if (!lp._bindings) {\r\n        lp._bindings = 0;\r\n      }\r\n      lp._bindings++;\r\n    },\r\n\r\n    // unbind the proxy events from the current app\r\n    unbind: function() {\r\n      $(window).unbind('hashchange.' + this.app.eventNamespace());\r\n      $(window).unbind('popstate.' + this.app.eventNamespace());\r\n      $('a').die('click.history-' + this.app.eventNamespace());\r\n      Sammy.DefaultLocationProxy._bindings--;\r\n      if (Sammy.DefaultLocationProxy._bindings <= 0) {\r\n        window.clearInterval(Sammy.DefaultLocationProxy._interval);\r\n      }\r\n    },\r\n\r\n    // get the current location from the hash.\r\n    getLocation: function() {\r\n      return Sammy.DefaultLocationProxy.fullPath(window.location);\r\n    },\r\n\r\n    // set the current location to `new_location`\r\n    setLocation: function(new_location) {\r\n      if (/^([^#\\/]|$)/.test(new_location)) { // non-prefixed url\r\n        if (_has_history && !this.app.disable_push_state) {\r\n          new_location = '/' + new_location;\r\n        } else {\r\n          new_location = '#!/' + new_location;\r\n        }\r\n      }\r\n      if (new_location != this.getLocation()) {\r\n        // HTML5 History exists and new_location is a full path\r\n        if (_has_history && !this.app.disable_push_state && /^\\//.test(new_location)) {\r\n          history.pushState({ path: new_location }, window.title, new_location);\r\n          this.app.trigger('location-changed');\r\n        } else {\r\n          return (window.location = new_location);\r\n        }\r\n      }\r\n    },\r\n\r\n    _startPolling: function(every) {\r\n      // set up interval\r\n      var proxy = this;\r\n      if (!Sammy.DefaultLocationProxy._interval) {\r\n        if (!every) { every = 10; }\r\n        var hashCheck = function() {\r\n          var current_location = proxy.getLocation();\r\n          if (typeof Sammy.DefaultLocationProxy._last_location == 'undefined' ||\r\n            current_location != Sammy.DefaultLocationProxy._last_location) {\r\n            window.setTimeout(function() {\r\n              $(window).trigger('hashchange', [true]);\r\n            }, 0);\r\n          }\r\n          Sammy.DefaultLocationProxy._last_location = current_location;\r\n        };\r\n        hashCheck();\r\n        Sammy.DefaultLocationProxy._interval = window.setInterval(hashCheck, every);\r\n      }\r\n    }\r\n  });\r\n\r\n\r\n  // Sammy.Application is the Base prototype for defining 'applications'.\r\n  // An 'application' is a collection of 'routes' and bound events that is\r\n  // attached to an element when `run()` is called.\r\n  // The only argument an 'app_function' is evaluated within the context of the application.\r\n  Sammy.Application = function(app_function) {\r\n    var app = this;\r\n    this.routes            = {};\r\n    this.listeners         = new Sammy.Object({});\r\n    this.arounds           = [];\r\n    this.befores           = [];\r\n    // generate a unique namespace\r\n    this.namespace         = (new Date()).getTime() + '-' + parseInt(Math.random() * 1000, 10);\r\n    this.context_prototype = function() { Sammy.EventContext.apply(this, arguments); };\r\n    this.context_prototype.prototype = new Sammy.EventContext();\r\n\r\n    if (_isFunction(app_function)) {\r\n      app_function.apply(this, [this]);\r\n    }\r\n    // set the location proxy if not defined to the default (DefaultLocationProxy)\r\n    if (!this._location_proxy) {\r\n      this.setLocationProxy(new Sammy.DefaultLocationProxy(this, this.run_interval_every));\r\n    }\r\n    if (this.debug) {\r\n      this.bindToAllEvents(function(e, data) {\r\n        app.log(app.toString(), e.cleaned_type, data || {});\r\n      });\r\n    }\r\n  };\r\n\r\n  Sammy.Application.prototype = $.extend({}, Sammy.Object.prototype, {\r\n\r\n    // the four route verbs\r\n    ROUTE_VERBS: ['get','post','put','delete'],\r\n\r\n    // An array of the default events triggered by the\r\n    // application during its lifecycle\r\n    APP_EVENTS: ['run', 'unload', 'lookup-route', 'run-route', 'route-found', 'event-context-before', 'event-context-after', 'changed', 'error', 'check-form-submission', 'redirect', 'location-changed'],\r\n\r\n    _last_route: null,\r\n    _location_proxy: null,\r\n    _running: false,\r\n\r\n    // Defines what element the application is bound to. Provide a selector\r\n    // (parseable by `jQuery()`) and this will be used by `$element()`\r\n    element_selector: 'body',\r\n\r\n    // When set to true, logs all of the default events using `log()`\r\n    debug: false,\r\n\r\n    // When set to true, and the error() handler is not overridden, will actually\r\n    // raise JS errors in routes (500) and when routes can't be found (404)\r\n    raise_errors: false,\r\n\r\n    // The time in milliseconds that the URL is queried for changes\r\n    run_interval_every: 50,\r\n\r\n    // if using the `DefaultLocationProxy` setting this to true will force the app to use\r\n    // traditional hash based routing as opposed to the new HTML5 PushState support\r\n    disable_push_state: false,\r\n\r\n    // The default template engine to use when using `partial()` in an\r\n    // `EventContext`. `template_engine` can either be a string that\r\n    // corresponds to the name of a method/helper on EventContext or it can be a function\r\n    // that takes two arguments, the content of the unrendered partial and an optional\r\n    // JS object that contains interpolation data. Template engine is only called/referred\r\n    // to if the extension of the partial is null or unknown. See `partial()`\r\n    // for more information\r\n    template_engine: null,\r\n\r\n    // //=> Sammy.Application: body\r\n    toString: function() {\r\n      return 'Sammy.Application:' + this.element_selector;\r\n    },\r\n\r\n    // returns a jQuery object of the Applications bound element.\r\n    $element: function(selector) {\r\n      return selector ? $(this.element_selector).find(selector) : $(this.element_selector);\r\n    },\r\n\r\n    // `use()` is the entry point for including Sammy plugins.\r\n    // The first argument to use should be a function() that is evaluated\r\n    // in the context of the current application, just like the `app_function`\r\n    // argument to the `Sammy.Application` constructor.\r\n    //\r\n    // Any additional arguments are passed to the app function sequentially.\r\n    //\r\n    // For much more detail about plugins, check out:\r\n    // [http://sammyjs.org/docs/plugins](http://sammyjs.org/docs/plugins)\r\n    //\r\n    // ### Example\r\n    //\r\n    //      var MyPlugin = function(app, prepend) {\r\n    //\r\n    //        this.helpers({\r\n    //          myhelper: function(text) {\r\n    //            alert(prepend + \" \" + text);\r\n    //          }\r\n    //        });\r\n    //\r\n    //      };\r\n    //\r\n    //      var app = $.sammy(function() {\r\n    //\r\n    //        this.use(MyPlugin, 'This is my plugin');\r\n    //\r\n    //        this.get('#/', function() {\r\n    //          this.myhelper('and dont you forget it!');\r\n    //          //=> Alerts: This is my plugin and dont you forget it!\r\n    //        });\r\n    //\r\n    //      });\r\n    //\r\n    // If plugin is passed as a string it assumes your are trying to load\r\n    // Sammy.\"Plugin\". This is the preferred way of loading core Sammy plugins\r\n    // as it allows for better error-messaging.\r\n    //\r\n    // ### Example\r\n    //\r\n    //      $.sammy(function() {\r\n    //        this.use('Mustache'); //=> Sammy.Mustache\r\n    //        this.use('Storage'); //=> Sammy.Storage\r\n    //      });\r\n    //\r\n    use: function() {\r\n      // flatten the arguments\r\n      var args = _makeArray(arguments),\r\n          plugin = args.shift(),\r\n          plugin_name = plugin || '';\r\n      try {\r\n        args.unshift(this);\r\n        if (typeof plugin == 'string') {\r\n          plugin_name = 'Sammy.' + plugin;\r\n          plugin = Sammy[plugin];\r\n        }\r\n        plugin.apply(this, args);\r\n      } catch(e) {\r\n        if (typeof plugin === 'undefined') {\r\n          this.error(\"Plugin Error: called use() but plugin (\" + plugin_name.toString() + \") is not defined\", e);\r\n        } else if (!_isFunction(plugin)) {\r\n          this.error(\"Plugin Error: called use() but '\" + plugin_name.toString() + \"' is not a function\", e);\r\n        } else {\r\n          this.error(\"Plugin Error\", e);\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Sets the location proxy for the current app. By default this is set to\r\n    // a new `Sammy.DefaultLocationProxy` on initialization. However, you can set\r\n    // the location_proxy inside you're app function to give your app a custom\r\n    // location mechanism. See `Sammy.DefaultLocationProxy` and `Sammy.DataLocationProxy`\r\n    // for examples.\r\n    //\r\n    // `setLocationProxy()` takes an initialized location proxy.\r\n    //\r\n    // ### Example\r\n    //\r\n    //        // to bind to data instead of the default hash;\r\n    //        var app = $.sammy(function() {\r\n    //          this.setLocationProxy(new Sammy.DataLocationProxy(this));\r\n    //        });\r\n    //\r\n    setLocationProxy: function(new_proxy) {\r\n      var original_proxy = this._location_proxy;\r\n      this._location_proxy = new_proxy;\r\n      if (this.isRunning()) {\r\n        if (original_proxy) {\r\n          // if there is already a location proxy, unbind it.\r\n          original_proxy.unbind();\r\n        }\r\n        this._location_proxy.bind();\r\n      }\r\n    },\r\n\r\n  // provide log() override for inside an app that includes the relevant application element_selector\r\n    log: function() {\r\n      Sammy.log.apply(Sammy, Array.prototype.concat.apply([this.element_selector],arguments));\r\n    },\r\n\r\n\r\n    // `route()` is the main method for defining routes within an application.\r\n    // For great detail on routes, check out:\r\n    // [http://sammyjs.org/docs/routes](http://sammyjs.org/docs/routes)\r\n    //\r\n    // This method also has aliases for each of the different verbs (eg. `get()`, `post()`, etc.)\r\n    //\r\n    // ### Arguments\r\n    //\r\n    // * `verb` A String in the set of ROUTE_VERBS or 'any'. 'any' will add routes for each\r\n    //    of the ROUTE_VERBS. If only two arguments are passed,\r\n    //    the first argument is the path, the second is the callback and the verb\r\n    //    is assumed to be 'any'.\r\n    // * `path` A Regexp or a String representing the path to match to invoke this verb.\r\n    // * `callback` A Function that is called/evaluated when the route is run see: `runRoute()`.\r\n    //    It is also possible to pass a string as the callback, which is looked up as the name\r\n    //    of a method on the application.\r\n    //\r\n    route: function(verb, path, callback) {\r\n      var app = this, param_names = [], add_route, path_match;\r\n\r\n      // if the method signature is just (path, callback)\r\n      // assume the verb is 'any'\r\n      if (!callback && _isFunction(path)) {\r\n        path = verb;\r\n        callback = path;\r\n        verb = 'any';\r\n      }\r\n\r\n      verb = verb.toLowerCase(); // ensure verb is lower case\r\n\r\n      // if path is a string turn it into a regex\r\n      if (path.constructor == String) {\r\n\r\n        // Needs to be explicitly set because IE will maintain the index unless NULL is returned,\r\n        // which means that with two consecutive routes that contain params, the second set of params will not be found and end up in splat instead of params\r\n        // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/RegExp/lastIndex\r\n        PATH_NAME_MATCHER.lastIndex = 0;\r\n\r\n        // find the names\r\n        while ((path_match = PATH_NAME_MATCHER.exec(path)) !== null) {\r\n          param_names.push(path_match[1]);\r\n        }\r\n        // replace with the path replacement\r\n        path = new RegExp(path.replace(PATH_NAME_MATCHER, PATH_REPLACER) + \"$\");\r\n      }\r\n      // lookup callback\r\n      if (typeof callback == 'string') {\r\n        callback = app[callback];\r\n      }\r\n\r\n      add_route = function(with_verb) {\r\n        var r = {verb: with_verb, path: path, callback: callback, param_names: param_names};\r\n        // add route to routes array\r\n        app.routes[with_verb] = app.routes[with_verb] || [];\r\n        // place routes in order of definition\r\n        app.routes[with_verb].push(r);\r\n      };\r\n\r\n      if (verb === 'any') {\r\n        $.each(this.ROUTE_VERBS, function(i, v) { add_route(v); });\r\n      } else {\r\n        add_route(verb);\r\n      }\r\n\r\n      // return the app\r\n      return this;\r\n    },\r\n\r\n    // Alias for route('get', ...)\r\n    get: _routeWrapper('get'),\r\n\r\n    // Alias for route('post', ...)\r\n    post: _routeWrapper('post'),\r\n\r\n    // Alias for route('put', ...)\r\n    put: _routeWrapper('put'),\r\n\r\n    // Alias for route('delete', ...)\r\n    del: _routeWrapper('delete'),\r\n\r\n    // Alias for route('any', ...)\r\n    any: _routeWrapper('any'),\r\n\r\n    // `mapRoutes` takes an array of arrays, each array being passed to route()\r\n    // as arguments, this allows for mass definition of routes. Another benefit is\r\n    // this makes it possible/easier to load routes via remote JSON.\r\n    //\r\n    // ### Example\r\n    //\r\n    //      var app = $.sammy(function() {\r\n    //\r\n    //        this.mapRoutes([\r\n    //            ['get', '#/', function() { this.log('index'); }],\r\n    //            // strings in callbacks are looked up as methods on the app\r\n    //            ['post', '#/create', 'addUser'],\r\n    //            // No verb assumes 'any' as the verb\r\n    //            [/dowhatever/, function() { this.log(this.verb, this.path)}];\r\n    //          ]);\r\n    //      });\r\n    //\r\n    mapRoutes: function(route_array) {\r\n      var app = this;\r\n      $.each(route_array, function(i, route_args) {\r\n        app.route.apply(app, route_args);\r\n      });\r\n      return this;\r\n    },\r\n\r\n    // A unique event namespace defined per application.\r\n    // All events bound with `bind()` are automatically bound within this space.\r\n    eventNamespace: function() {\r\n      return ['sammy-app', this.namespace].join('-');\r\n    },\r\n\r\n    // Works just like `jQuery.fn.bind()` with a couple notable differences.\r\n    //\r\n    // * It binds all events to the application element\r\n    // * All events are bound within the `eventNamespace()`\r\n    // * Events are not actually bound until the application is started with `run()`\r\n    // * callbacks are evaluated within the context of a Sammy.EventContext\r\n    //\r\n    bind: function(name, data, callback) {\r\n      var app = this;\r\n      // build the callback\r\n      // if the arity is 2, callback is the second argument\r\n      if (typeof callback == 'undefined') { callback = data; }\r\n      var listener_callback =  function() {\r\n        // pull off the context from the arguments to the callback\r\n        var e, context, data;\r\n        e       = arguments[0];\r\n        data    = arguments[1];\r\n        if (data && data.context) {\r\n          context = data.context;\r\n          delete data.context;\r\n        } else {\r\n          context = new app.context_prototype(app, 'bind', e.type, data, e.target);\r\n        }\r\n        e.cleaned_type = e.type.replace(app.eventNamespace(), '');\r\n        callback.apply(context, [e, data]);\r\n      };\r\n\r\n      // it could be that the app element doesnt exist yet\r\n      // so attach to the listeners array and then run()\r\n      // will actually bind the event.\r\n      if (!this.listeners[name]) { this.listeners[name] = []; }\r\n      this.listeners[name].push(listener_callback);\r\n      if (this.isRunning()) {\r\n        // if the app is running\r\n        // *actually* bind the event to the app element\r\n        this._listen(name, listener_callback);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Triggers custom events defined with `bind()`\r\n    //\r\n    // ### Arguments\r\n    //\r\n    // * `name` The name of the event. Automatically prefixed with the `eventNamespace()`\r\n    // * `data` An optional Object that can be passed to the bound callback.\r\n    // * `context` An optional context/Object in which to execute the bound callback.\r\n    //   If no context is supplied a the context is a new `Sammy.EventContext`\r\n    //\r\n    trigger: function(name, data) {\r\n      this.$element().trigger([name, this.eventNamespace()].join('.'), [data]);\r\n      return this;\r\n    },\r\n\r\n    // Reruns the current route\r\n    refresh: function() {\r\n      this.last_location = null;\r\n      this.trigger('location-changed');\r\n      return this;\r\n    },\r\n\r\n    // Takes a single callback that is pushed on to a stack.\r\n    // Before any route is run, the callbacks are evaluated in order within\r\n    // the current `Sammy.EventContext`\r\n    //\r\n    // If any of the callbacks explicitly return false, execution of any\r\n    // further callbacks and the route itself is halted.\r\n    //\r\n    // You can also provide a set of options that will define when to run this\r\n    // before based on the route it proceeds.\r\n    //\r\n    // ### Example\r\n    //\r\n    //      var app = $.sammy(function() {\r\n    //\r\n    //        // will run at #/route but not at #/\r\n    //        this.before('#/route', function() {\r\n    //          //...\r\n    //        });\r\n    //\r\n    //        // will run at #/ but not at #/route\r\n    //        this.before({except: {path: '#/route'}}, function() {\r\n    //          this.log('not before #/route');\r\n    //        });\r\n    //\r\n    //        this.get('#/', function() {});\r\n    //\r\n    //        this.get('#/route', function() {});\r\n    //\r\n    //      });\r\n    //\r\n    // See `contextMatchesOptions()` for a full list of supported options\r\n    //\r\n    before: function(options, callback) {\r\n      if (_isFunction(options)) {\r\n        callback = options;\r\n        options = {};\r\n      }\r\n      this.befores.push([options, callback]);\r\n      return this;\r\n    },\r\n\r\n    // A shortcut for binding a callback to be run after a route is executed.\r\n    // After callbacks have no guarunteed order.\r\n    after: function(callback) {\r\n      return this.bind('event-context-after', callback);\r\n    },\r\n\r\n\r\n    // Adds an around filter to the application. around filters are functions\r\n    // that take a single argument `callback` which is the entire route\r\n    // execution path wrapped up in a closure. This means you can decide whether\r\n    // or not to proceed with execution by not invoking `callback` or,\r\n    // more usefully wrapping callback inside the result of an asynchronous execution.\r\n    //\r\n    // ### Example\r\n    //\r\n    // The most common use case for around() is calling a _possibly_ async function\r\n    // and executing the route within the functions callback:\r\n    //\r\n    //      var app = $.sammy(function() {\r\n    //\r\n    //        var current_user = false;\r\n    //\r\n    //        function checkLoggedIn(callback) {\r\n    //          // /session returns a JSON representation of the logged in user\r\n    //          // or an empty object\r\n    //          if (!current_user) {\r\n    //            $.getJSON('/session', function(json) {\r\n    //              if (json.login) {\r\n    //                // show the user as logged in\r\n    //                current_user = json;\r\n    //                // execute the route path\r\n    //                callback();\r\n    //              } else {\r\n    //                // show the user as not logged in\r\n    //                current_user = false;\r\n    //                // the context of aroundFilters is an EventContext\r\n    //                this.redirect('#/login');\r\n    //              }\r\n    //            });\r\n    //          } else {\r\n    //            // execute the route path\r\n    //            callback();\r\n    //          }\r\n    //        };\r\n    //\r\n    //        this.around(checkLoggedIn);\r\n    //\r\n    //      });\r\n    //\r\n    around: function(callback) {\r\n      this.arounds.push(callback);\r\n      return this;\r\n    },\r\n\r\n    // Returns `true` if the current application is running.\r\n    isRunning: function() {\r\n      return this._running;\r\n    },\r\n\r\n    // Helpers extends the EventContext prototype specific to this app.\r\n    // This allows you to define app specific helper functions that can be used\r\n    // whenever you're inside of an event context (templates, routes, bind).\r\n    //\r\n    // ### Example\r\n    //\r\n    //     var app = $.sammy(function() {\r\n    //\r\n    //       helpers({\r\n    //         upcase: function(text) {\r\n    //          return text.toString().toUpperCase();\r\n    //         }\r\n    //       });\r\n    //\r\n    //       get('#/', function() { with(this) {\r\n    //         // inside of this context I can use the helpers\r\n    //         $('#main').html(upcase($('#main').text());\r\n    //       }});\r\n    //\r\n    //     });\r\n    //\r\n    //\r\n    // ### Arguments\r\n    //\r\n    // * `extensions` An object collection of functions to extend the context.\r\n    //\r\n    helpers: function(extensions) {\r\n      $.extend(this.context_prototype.prototype, extensions);\r\n      return this;\r\n    },\r\n\r\n    // Helper extends the event context just like `helpers()` but does it\r\n    // a single method at a time. This is especially useful for dynamically named\r\n    // helpers\r\n    //\r\n    // ### Example\r\n    //\r\n    //     // Trivial example that adds 3 helper methods to the context dynamically\r\n    //     var app = $.sammy(function(app) {\r\n    //\r\n    //       $.each([1,2,3], function(i, num) {\r\n    //         app.helper('helper' + num, function() {\r\n    //           this.log(\"I'm helper number \" + num);\r\n    //         });\r\n    //       });\r\n    //\r\n    //       this.get('#/', function() {\r\n    //         this.helper2(); //=> I'm helper number 2\r\n    //       });\r\n    //     });\r\n    //\r\n    // ### Arguments\r\n    //\r\n    // * `name` The name of the method\r\n    // * `method` The function to be added to the prototype at `name`\r\n    //\r\n    helper: function(name, method) {\r\n      this.context_prototype.prototype[name] = method;\r\n      return this;\r\n    },\r\n\r\n    // Actually starts the application's lifecycle. `run()` should be invoked\r\n    // within a document.ready block to ensure the DOM exists before binding events, etc.\r\n    //\r\n    // ### Example\r\n    //\r\n    //     var app = $.sammy(function() { ... }); // your application\r\n    //     $(function() { // document.ready\r\n    //        app.run();\r\n    //     });\r\n    //\r\n    // ### Arguments\r\n    //\r\n    // * `start_url` Optionally, a String can be passed which the App will redirect to\r\n    //   after the events/routes have been bound.\r\n    run: function(start_url) {\r\n      if (this.isRunning()) { return false; }\r\n      var app = this;\r\n\r\n      // actually bind all the listeners\r\n      $.each(this.listeners.toHash(), function(name, callbacks) {\r\n        $.each(callbacks, function(i, listener_callback) {\r\n          app._listen(name, listener_callback);\r\n        });\r\n      });\r\n\r\n      this.trigger('run', {start_url: start_url});\r\n      this._running = true;\r\n      // set last location\r\n      this.last_location = null;\r\n      if (!(/\\#(.+)/.test(this.getLocation())) && typeof start_url != 'undefined') {\r\n        this.setLocation(start_url);\r\n      }\r\n      // check url\r\n      this._checkLocation();\r\n      this._location_proxy.bind();\r\n      this.bind('location-changed', function() {\r\n        app._checkLocation();\r\n      });\r\n\r\n      // bind to submit to capture post/put/delete routes\r\n      this.bind('submit', function(e) {\r\n        var returned = app._checkFormSubmission($(e.target).closest('form'));\r\n        return (returned === false) ? e.preventDefault() : false;\r\n      });\r\n\r\n      // bind unload to body unload\r\n      $(window).bind('unload', function() {\r\n        app.unload();\r\n      });\r\n\r\n      // trigger html changed\r\n      return this.trigger('changed');\r\n    },\r\n\r\n    // The opposite of `run()`, un-binds all event listeners and intervals\r\n    // `run()` Automatically binds a `onunload` event to run this when\r\n    // the document is closed.\r\n    unload: function() {\r\n      if (!this.isRunning()) { return false; }\r\n      var app = this;\r\n      this.trigger('unload');\r\n      // clear interval\r\n      this._location_proxy.unbind();\r\n      // unbind form submits\r\n      this.$element().unbind('submit').removeClass(app.eventNamespace());\r\n      // unbind all events\r\n      $.each(this.listeners.toHash() , function(name, listeners) {\r\n        $.each(listeners, function(i, listener_callback) {\r\n          app._unlisten(name, listener_callback);\r\n        });\r\n      });\r\n      this._running = false;\r\n      return this;\r\n    },\r\n\r\n    // Not only runs `unbind` but also destroys the app reference.\r\n    destroy: function() {\r\n      this.unload();\r\n      delete Sammy.apps[this.element_selector];\r\n      return this;      \r\n    },\r\n\r\n    // Will bind a single callback function to every event that is already\r\n    // being listened to in the app. This includes all the `APP_EVENTS`\r\n    // as well as any custom events defined with `bind()`.\r\n    //\r\n    // Used internally for debug logging.\r\n    bindToAllEvents: function(callback) {\r\n      var app = this;\r\n      // bind to the APP_EVENTS first\r\n      $.each(this.APP_EVENTS, function(i, e) {\r\n        app.bind(e, callback);\r\n      });\r\n      // next, bind to listener names (only if they dont exist in APP_EVENTS)\r\n      $.each(this.listeners.keys(true), function(i, name) {\r\n        if ($.inArray(name, app.APP_EVENTS) == -1) {\r\n          app.bind(name, callback);\r\n        }\r\n      });\r\n      return this;\r\n    },\r\n\r\n    // Returns a copy of the given path with any query string after the hash\r\n    // removed.\r\n    routablePath: function(path) {\r\n      return path.replace(QUERY_STRING_MATCHER, '');\r\n    },\r\n\r\n    // Given a verb and a String path, will return either a route object or false\r\n    // if a matching route can be found within the current defined set.\r\n    lookupRoute: function(verb, path) {\r\n      var app = this, routed = false, i = 0, l, route;\r\n      if (typeof this.routes[verb] != 'undefined') {\r\n        l = this.routes[verb].length;\r\n        for (; i < l; i++) {\r\n          route = this.routes[verb][i];\r\n          if (app.routablePath(path).match(route.path)) {\r\n            routed = route;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return routed;\r\n    },\r\n\r\n    // First, invokes `lookupRoute()` and if a route is found, parses the\r\n    // possible URL params and then invokes the route's callback within a new\r\n    // `Sammy.EventContext`. If the route can not be found, it calls\r\n    // `notFound()`. If `raise_errors` is set to `true` and\r\n    // the `error()` has not been overridden, it will throw an actual JS\r\n    // error.\r\n    //\r\n    // You probably will never have to call this directly.\r\n    //\r\n    // ### Arguments\r\n    //\r\n    // * `verb` A String for the verb.\r\n    // * `path` A String path to lookup.\r\n    // * `params` An Object of Params pulled from the URI or passed directly.\r\n    //\r\n    // ### Returns\r\n    //\r\n    // Either returns the value returned by the route callback or raises a 404 Not Found error.\r\n    //\r\n    runRoute: function(verb, path, params, target) {\r\n      var app = this,\r\n          route = this.lookupRoute(verb, path),\r\n          context,\r\n          wrapped_route,\r\n          arounds,\r\n          around,\r\n          befores,\r\n          before,\r\n          callback_args,\r\n          path_params,\r\n          final_returned;\r\n\r\n      this.log('runRoute', [verb, path].join(' '));\r\n      this.trigger('run-route', {verb: verb, path: path, params: params});\r\n      if (typeof params == 'undefined') { params = {}; }\r\n\r\n      $.extend(params, this._parseQueryString(path));\r\n\r\n      if (route) {\r\n        this.trigger('route-found', {route: route});\r\n        // pull out the params from the path\r\n        if ((path_params = route.path.exec(this.routablePath(path))) !== null) {\r\n          // first match is the full path\r\n          path_params.shift();\r\n          // for each of the matches\r\n          $.each(path_params, function(i, param) {\r\n            // if theres a matching param name\r\n            if (route.param_names[i]) {\r\n              // set the name to the match\r\n              params[route.param_names[i]] = _decode(param);\r\n            } else {\r\n              // initialize 'splat'\r\n              if (!params.splat) { params.splat = []; }\r\n              params.splat.push(_decode(param));\r\n            }\r\n          });\r\n        }\r\n\r\n        // set event context\r\n        context  = new this.context_prototype(this, verb, path, params, target);\r\n        // ensure arrays\r\n        arounds = this.arounds.slice(0);\r\n        befores = this.befores.slice(0);\r\n        // set the callback args to the context + contents of the splat\r\n        callback_args = [context].concat(params.splat);\r\n        // wrap the route up with the before filters\r\n        wrapped_route = function() {\r\n          var returned;\r\n          while (befores.length > 0) {\r\n            before = befores.shift();\r\n            // check the options\r\n            if (app.contextMatchesOptions(context, before[0])) {\r\n              returned = before[1].apply(context, [context]);\r\n              if (returned === false) { return false; }\r\n            }\r\n          }\r\n          app.last_route = route;\r\n          context.trigger('event-context-before', {context: context});\r\n          returned = route.callback.apply(context, callback_args);\r\n          context.trigger('event-context-after', {context: context});\r\n          return returned;\r\n        };\r\n        $.each(arounds.reverse(), function(i, around) {\r\n          var last_wrapped_route = wrapped_route;\r\n          wrapped_route = function() { return around.apply(context, [last_wrapped_route]); };\r\n        });\r\n        try {\r\n          final_returned = wrapped_route();\r\n        } catch(e) {\r\n          this.error(['500 Error', verb, path].join(' '), e);\r\n        }\r\n        return final_returned;\r\n      } else {\r\n        return this.notFound(verb, path);\r\n      }\r\n    },\r\n\r\n    // Matches an object of options against an `EventContext` like object that\r\n    // contains `path` and `verb` attributes. Internally Sammy uses this\r\n    // for matching `before()` filters against specific options. You can set the\r\n    // object to _only_ match certain paths or verbs, or match all paths or verbs _except_\r\n    // those that match the options.\r\n    //\r\n    // ### Example\r\n    //\r\n    //     var app = $.sammy(),\r\n    //         context = {verb: 'get', path: '#/mypath'};\r\n    //\r\n    //     // match against a path string\r\n    //     app.contextMatchesOptions(context, '#/mypath'); //=> true\r\n    //     app.contextMatchesOptions(context, '#/otherpath'); //=> false\r\n    //     // equivalent to\r\n    //     app.contextMatchesOptions(context, {only: {path:'#/mypath'}}); //=> true\r\n    //     app.contextMatchesOptions(context, {only: {path:'#/otherpath'}}); //=> false\r\n    //     // match against a path regexp\r\n    //     app.contextMatchesOptions(context, /path/); //=> true\r\n    //     app.contextMatchesOptions(context, /^path/); //=> false\r\n    //     // match only a verb\r\n    //     app.contextMatchesOptions(context, {only: {verb:'get'}}); //=> true\r\n    //     app.contextMatchesOptions(context, {only: {verb:'post'}}); //=> false\r\n    //     // match all except a verb\r\n    //     app.contextMatchesOptions(context, {except: {verb:'post'}}); //=> true\r\n    //     app.contextMatchesOptions(context, {except: {verb:'get'}}); //=> false\r\n    //     // match all except a path\r\n    //     app.contextMatchesOptions(context, {except: {path:'#/otherpath'}}); //=> true\r\n    //     app.contextMatchesOptions(context, {except: {path:'#/mypath'}}); //=> false\r\n    //     // match multiple paths\r\n    //     app.contextMatchesOptions(context, {path: ['#/mypath', '#/otherpath']}); //=> true\r\n    //     app.contextMatchesOptions(context, {path: ['#/otherpath', '#/thirdpath']}); //=> false\r\n    //     // equivalent to\r\n    //     app.contextMatchesOptions(context, {only: {path: ['#/mypath', '#/otherpath']}}); //=> true\r\n    //     app.contextMatchesOptions(context, {only: {path: ['#/otherpath', '#/thirdpath']}}); //=> false\r\n    //     // match all except multiple paths\r\n    //     app.contextMatchesOptions(context, {except: {path: ['#/mypath', '#/otherpath']}}); //=> false\r\n    //     app.contextMatchesOptions(context, {except: {path: ['#/otherpath', '#/thirdpath']}}); //=> true\r\n    //\r\n    contextMatchesOptions: function(context, match_options, positive) {\r\n      var options = match_options;\r\n      // normalize options\r\n      if (typeof options === 'string' || _isRegExp(options)) {\r\n        options = {path: options};\r\n      }\r\n      if (typeof positive === 'undefined') {\r\n        positive = true;\r\n      }\r\n      // empty options always match\r\n      if ($.isEmptyObject(options)) {\r\n        return true;\r\n      }\r\n      // Do we have to match against multiple paths?\r\n      if (_isArray(options.path)){\r\n        var results, numopt, opts, len;\r\n        results = [];\r\n        for (numopt = 0, len = options.path.length; numopt < len; numopt += 1) {\r\n          opts = $.extend({}, options, {path: options.path[numopt]});\r\n          results.push(this.contextMatchesOptions(context, opts));\r\n        }\r\n        var matched = $.inArray(true, results) > -1 ? true : false;\r\n        return positive ? matched : !matched;\r\n      }\r\n      if (options.only) {\r\n        return this.contextMatchesOptions(context, options.only, true);\r\n      } else if (options.except) {\r\n        return this.contextMatchesOptions(context, options.except, false);\r\n      }\r\n      var path_matched = true, verb_matched = true;\r\n      if (options.path) {\r\n        if (!_isRegExp(options.path)) {\r\n          options.path = new RegExp(options.path.toString() + '$');\r\n        }\r\n        path_matched = options.path.test(context.path);\r\n      }\r\n      if (options.verb) {\r\n        if(typeof options.verb === 'string') {\r\n          verb_matched = options.verb === context.verb;\r\n        } else {\r\n          verb_matched = options.verb.indexOf(context.verb) > -1;\r\n        }\r\n      }\r\n      return positive ? (verb_matched && path_matched) : !(verb_matched && path_matched);\r\n    },\r\n\r\n\r\n    // Delegates to the `location_proxy` to get the current location.\r\n    // See `Sammy.DefaultLocationProxy` for more info on location proxies.\r\n    getLocation: function() {\r\n      return this._location_proxy.getLocation();\r\n    },\r\n\r\n    // Delegates to the `location_proxy` to set the current location.\r\n    // See `Sammy.DefaultLocationProxy` for more info on location proxies.\r\n    //\r\n    // ### Arguments\r\n    //\r\n    // * `new_location` A new location string (e.g. '#/')\r\n    //\r\n    setLocation: function(new_location) {\r\n      return this._location_proxy.setLocation(new_location);\r\n    },\r\n\r\n    // Swaps the content of `$element()` with `content`\r\n    // You can override this method to provide an alternate swap behavior\r\n    // for `EventContext.partial()`.\r\n    //\r\n    // ### Example\r\n    //\r\n    //      var app = $.sammy(function() {\r\n    //\r\n    //        // implements a 'fade out'/'fade in'\r\n    //        this.swap = function(content, callback) {\r\n    //          var context = this;\r\n    //          context.$element().fadeOut('slow', function() {\r\n    //            context.$element().html(content);\r\n    //            context.$element().fadeIn('slow', function() {\r\n    //              if (callback) {\r\n    //                callback.apply();\r\n    //              }\r\n    //            });\r\n    //          });\r\n    //        };\r\n    //\r\n    //      });\r\n    //\r\n    swap: function(content, callback) {\r\n      var $el = this.$element().html(content);\r\n      if (_isFunction(callback)) { callback(content); }\r\n      return $el;\r\n    },\r\n\r\n    // a simple global cache for templates. Uses the same semantics as\r\n    // `Sammy.Cache` and `Sammy.Storage` so can easily be replaced with\r\n    // a persistent storage that lasts beyond the current request.\r\n    templateCache: function(key, value) {\r\n      if (typeof value != 'undefined') {\r\n        return _template_cache[key] = value;\r\n      } else {\r\n        return _template_cache[key];\r\n      }\r\n    },\r\n\r\n    // clear the templateCache\r\n    clearTemplateCache: function() {\r\n      return (_template_cache = {});\r\n    },\r\n\r\n    // This throws a '404 Not Found' error by invoking `error()`.\r\n    // Override this method or `error()` to provide custom\r\n    // 404 behavior (i.e redirecting to / or showing a warning)\r\n    notFound: function(verb, path) {\r\n      var ret = this.error(['404 Not Found', verb, path].join(' '));\r\n      return (verb === 'get') ? ret : true;\r\n    },\r\n\r\n    // The base error handler takes a string `message` and an `Error`\r\n    // object. If `raise_errors` is set to `true` on the app level,\r\n    // this will re-throw the error to the browser. Otherwise it will send the error\r\n    // to `log()`. Override this method to provide custom error handling\r\n    // e.g logging to a server side component or displaying some feedback to the\r\n    // user.\r\n    error: function(message, original_error) {\r\n      if (!original_error) { original_error = new Error(); }\r\n      original_error.message = [message, original_error.message].join(' ');\r\n      this.trigger('error', {message: original_error.message, error: original_error});\r\n      if (this.raise_errors) {\r\n        throw(original_error);\r\n      } else {\r\n        this.log(original_error.message, original_error);\r\n      }\r\n    },\r\n\r\n    _checkLocation: function() {\r\n      var location, returned;\r\n      // get current location\r\n      location = this.getLocation();\r\n      // compare to see if hash has changed\r\n      if (!this.last_location || this.last_location[0] != 'get' || this.last_location[1] != location) {\r\n        // reset last location\r\n        this.last_location = ['get', location];\r\n        // lookup route for current hash\r\n        returned = this.runRoute('get', location);\r\n      }\r\n      return returned;\r\n    },\r\n\r\n    _getFormVerb: function(form) {\r\n      var $form = $(form), verb, $_method;\r\n      $_method = $form.find('input[name=\"_method\"]');\r\n      if ($_method.length > 0) { verb = $_method.val(); }\r\n      if (!verb) { verb = $form[0].getAttribute('method'); }\r\n      if (!verb || verb === '') { verb = 'get'; }\r\n      return $.trim(verb.toString().toLowerCase());\r\n    },\r\n\r\n    _checkFormSubmission: function(form) {\r\n      var $form, path, verb, params, returned;\r\n      this.trigger('check-form-submission', {form: form});\r\n      $form = $(form);\r\n      path  = $form.attr('action') || '';\r\n      verb  = this._getFormVerb($form);\r\n      this.log('_checkFormSubmission', $form, path, verb);\r\n      if (verb === 'get') {\r\n        params = this._serializeFormParams($form);\r\n        if (params !== '') { path += '?' + params; }\r\n        this.setLocation(path);\r\n        returned = false;\r\n      } else {\r\n        params = $.extend({}, this._parseFormParams($form));\r\n        returned = this.runRoute(verb, path, params, form.get(0));\r\n      }\r\n      return (typeof returned == 'undefined') ? false : returned;\r\n    },\r\n\r\n    _serializeFormParams: function($form) {\r\n       var queryString = \"\",\r\n         fields = $form.serializeArray(),\r\n         i;\r\n       if (fields.length > 0) {\r\n         queryString = this._encodeFormPair(fields[0].name, fields[0].value);\r\n         for (i = 1; i < fields.length; i++) {\r\n           queryString = queryString + \"&\" + this._encodeFormPair(fields[i].name, fields[i].value);\r\n         }\r\n       }\r\n       return queryString;\r\n    },\r\n\r\n    _encodeFormPair: function(name, value){\r\n      return _encode(name) + \"=\" + _encode(value);\r\n    },\r\n\r\n    _parseFormParams: function($form) {\r\n      var params = {},\r\n          form_fields = $form.serializeArray(),\r\n          i;\r\n      for (i = 0; i < form_fields.length; i++) {\r\n        params = this._parseParamPair(params, form_fields[i].name, form_fields[i].value);\r\n      }\r\n      return params;\r\n    },\r\n\r\n    _parseQueryString: function(path) {\r\n      var params = {}, parts, pairs, pair, i;\r\n\r\n      parts = path.match(QUERY_STRING_MATCHER);\r\n      if (parts && parts[1]) {\r\n        pairs = parts[1].split('&');\r\n        for (i = 0; i < pairs.length; i++) {\r\n          pair = pairs[i].split('=');\r\n          params = this._parseParamPair(params, _decode(pair[0]), _decode(pair[1] || \"\"));\r\n        }\r\n      }\r\n      return params;\r\n    },\r\n\r\n    _parseParamPair: function(params, key, value) {\r\n      if (typeof params[key] !== 'undefined') {\r\n        if (_isArray(params[key])) {\r\n          params[key].push(value);\r\n        } else {\r\n          params[key] = [params[key], value];\r\n        }\r\n      } else {\r\n        params[key] = value;\r\n      }\r\n      return params;\r\n    },\r\n\r\n    _listen: function(name, callback) {\r\n      return this.$element().bind([name, this.eventNamespace()].join('.'), callback);\r\n    },\r\n\r\n    _unlisten: function(name, callback) {\r\n      return this.$element().unbind([name, this.eventNamespace()].join('.'), callback);\r\n    }\r\n\r\n  });\r\n\r\n  // `Sammy.RenderContext` is an object that makes sequential template loading,\r\n  // rendering and interpolation seamless even when dealing with asynchronous\r\n  // operations.\r\n  //\r\n  // `RenderContext` objects are not usually created directly, rather they are\r\n  // instantiated from an `Sammy.EventContext` by using `render()`, `load()` or\r\n  // `partial()` which all return `RenderContext` objects.\r\n  //\r\n  // `RenderContext` methods always returns a modified `RenderContext`\r\n  // for chaining (like jQuery itself).\r\n  //\r\n  // The core magic is in the `then()` method which puts the callback passed as\r\n  // an argument into a queue to be executed once the previous callback is complete.\r\n  // All the methods of `RenderContext` are wrapped in `then()` which allows you\r\n  // to queue up methods by chaining, but maintaining a guaranteed execution order\r\n  // even with remote calls to fetch templates.\r\n  //\r\n  Sammy.RenderContext = function(event_context) {\r\n    this.event_context    = event_context;\r\n    this.callbacks        = [];\r\n    this.previous_content = null;\r\n    this.content          = null;\r\n    this.next_engine      = false;\r\n    this.waiting          = false;\r\n  };\r\n\r\n  Sammy.RenderContext.prototype = $.extend({}, Sammy.Object.prototype, {\r\n\r\n    // The \"core\" of the `RenderContext` object, adds the `callback` to the\r\n    // queue. If the context is `waiting` (meaning an async operation is happening)\r\n    // then the callback will be executed in order, once the other operations are\r\n    // complete. If there is no currently executing operation, the `callback`\r\n    // is executed immediately.\r\n    //\r\n    // The value returned from the callback is stored in `content` for the\r\n    // subsequent operation. If you return `false`, the queue will pause, and\r\n    // the next callback in the queue will not be executed until `next()` is\r\n    // called. This allows for the guaranteed order of execution while working\r\n    // with async operations.\r\n    //\r\n    // If then() is passed a string instead of a function, the string is looked\r\n    // up as a helper method on the event context.\r\n    //\r\n    // ### Example\r\n    //\r\n    //      this.get('#/', function() {\r\n    //        // initialize the RenderContext\r\n    //        // Even though `load()` executes async, the next `then()`\r\n    //        // wont execute until the load finishes\r\n    //        this.load('myfile.txt')\r\n    //            .then(function(content) {\r\n    //              // the first argument to then is the content of the\r\n    //              // prev operation\r\n    //              $('#main').html(content);\r\n    //            });\r\n    //      });\r\n    //\r\n    then: function(callback) {\r\n      if (!_isFunction(callback)) {\r\n        // if a string is passed to then, assume we want to call\r\n        // a helper on the event context in its context\r\n        if (typeof callback === 'string' && callback in this.event_context) {\r\n          var helper = this.event_context[callback];\r\n          callback = function(content) {\r\n            return helper.apply(this.event_context, [content]);\r\n          };\r\n        } else {\r\n          return this;\r\n        }\r\n      }\r\n      var context = this;\r\n      if (this.waiting) {\r\n        this.callbacks.push(callback);\r\n      } else {\r\n        this.wait();\r\n        window.setTimeout(function() {\r\n          var returned = callback.apply(context, [context.content, context.previous_content]);\r\n          if (returned !== false) {\r\n            context.next(returned);\r\n          }\r\n        }, 0);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Pause the `RenderContext` queue. Combined with `next()` allows for async\r\n    // operations.\r\n    //\r\n    // ### Example\r\n    //\r\n    //        this.get('#/', function() {\r\n    //          this.load('mytext.json')\r\n    //              .then(function(content) {\r\n    //                var context = this,\r\n    //                    data    = JSON.parse(content);\r\n    //                // pause execution\r\n    //                context.wait();\r\n    //                // post to a url\r\n    //                $.post(data.url, {}, function(response) {\r\n    //                  context.next(JSON.parse(response));\r\n    //                });\r\n    //              })\r\n    //              .then(function(data) {\r\n    //                // data is json from the previous post\r\n    //                $('#message').text(data.status);\r\n    //              });\r\n    //        });\r\n    wait: function() {\r\n      this.waiting = true;\r\n    },\r\n\r\n    // Resume the queue, setting `content` to be used in the next operation.\r\n    // See `wait()` for an example.\r\n    next: function(content) {\r\n      this.waiting = false;\r\n      if (typeof content !== 'undefined') {\r\n        this.previous_content = this.content;\r\n        this.content = content;\r\n      }\r\n      if (this.callbacks.length > 0) {\r\n        this.then(this.callbacks.shift());\r\n      }\r\n    },\r\n\r\n    // Load a template into the context.\r\n    // The `location` can either be a string specifying the remote path to the\r\n    // file, a jQuery object, or a DOM element.\r\n    //\r\n    // No interpolation happens by default, the content is stored in\r\n    // `content`.\r\n    //\r\n    // In the case of a path, unless the option `{cache: false}` is passed the\r\n    // data is stored in the app's `templateCache()`.\r\n    //\r\n    // If a jQuery or DOM object is passed the `innerHTML` of the node is pulled in.\r\n    // This is useful for nesting templates as part of the initial page load wrapped\r\n    // in invisible elements or `<script>` tags. With template paths, the template\r\n    // engine is looked up by the extension. For DOM/jQuery embedded templates,\r\n    // this isnt possible, so there are a couple of options:\r\n    //\r\n    //  * pass an `{engine:}` option.\r\n    //  * define the engine in the `data-engine` attribute of the passed node.\r\n    //  * just store the raw template data and use `interpolate()` manually\r\n    //\r\n    // If a `callback` is passed it is executed after the template load.\r\n    load: function(location, options, callback) {\r\n      var context = this;\r\n      return this.then(function() {\r\n        var should_cache, cached, is_json, location_array;\r\n        if (_isFunction(options)) {\r\n          callback = options;\r\n          options = {};\r\n        } else {\r\n          options = $.extend({}, options);\r\n        }\r\n        if (callback) { this.then(callback); }\r\n        if (typeof location === 'string') {\r\n          // it's a path\r\n          is_json      = (location.match(/\\.json$/) || options.json);\r\n          should_cache = is_json ? options.cache === true : options.cache !== false;\r\n          context.next_engine = context.event_context.engineFor(location);\r\n          delete options.cache;\r\n          delete options.json;\r\n          if (options.engine) {\r\n            context.next_engine = options.engine;\r\n            delete options.engine;\r\n          }\r\n          if (should_cache && (cached = this.event_context.app.templateCache(location))) {\r\n            return cached;\r\n          }\r\n          this.wait();\r\n          $.ajax($.extend({\r\n            url: location,\r\n            data: {},\r\n            dataType: is_json ? 'json' : 'text',\r\n            type: 'get',\r\n            success: function(data) {\r\n              if (should_cache) {\r\n                context.event_context.app.templateCache(location, data);\r\n              }\r\n              context.next(data);\r\n            }\r\n          }, options));\r\n          return false;\r\n        } else {\r\n          // it's a dom/jQuery\r\n          if (location.nodeType) {\r\n            return location.innerHTML;\r\n          }\r\n          if (location.selector) {\r\n            // it's a jQuery\r\n            context.next_engine = location.attr('data-engine');\r\n            if (options.clone === false) {\r\n              return location.remove()[0].innerHTML.toString();\r\n            } else {\r\n              return location[0].innerHTML.toString();\r\n            }\r\n          }\r\n        }\r\n      });\r\n    },\r\n\r\n    // Load partials\r\n    //\r\n    // ### Example\r\n    //\r\n    //      this.loadPartials({mypartial: '/path/to/partial'});\r\n    //\r\n    loadPartials: function(partials) {\r\n      var name;\r\n      if(partials) {\r\n        this.partials = this.partials || {};\r\n        for(name in partials) {\r\n          (function(context, name) {\r\n            context.load(partials[name])\r\n                   .then(function(template) {\r\n                     this.partials[name] = template;\r\n                   });\r\n          })(this, name);\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // `load()` a template and then `interpolate()` it with data.\r\n    //\r\n    // can be called with multiple different signatures:\r\n    //\r\n    //      this.render(callback);\r\n    //      this.render('/location');\r\n    //      this.render('/location', {some: data});\r\n    //      this.render('/location', callback);\r\n    //      this.render('/location', {some: data}, callback);\r\n    //      this.render('/location', {some: data}, {my: partials});\r\n    //      this.render('/location', callback, {my: partials});\r\n    //      this.render('/location', {some: data}, callback, {my: partials});\r\n    //\r\n    // ### Example\r\n    //\r\n    //      this.get('#/', function() {\r\n    //        this.render('mytemplate.template', {name: 'test'});\r\n    //      });\r\n    //\r\n    render: function(location, data, callback, partials) {\r\n      if (_isFunction(location) && !data) {\r\n        // invoked as render(callback)\r\n        return this.then(location);\r\n      } else {\r\n        if(_isFunction(data)) {\r\n          // invoked as render(location, callback, [partials])\r\n          partials = callback;\r\n          callback = data;\r\n          data = null;\r\n        } else if(callback && !_isFunction(callback)) {\r\n          // invoked as render(location, data, partials)\r\n          partials = callback;\r\n          callback = null;\r\n        }\r\n\r\n        return this.loadPartials(partials)\r\n                   .load(location)\r\n                   .interpolate(data, location)\r\n                   .then(callback);\r\n      }\r\n    },\r\n\r\n    // `render()` the `location` with `data` and then `swap()` the\r\n    // app's `$element` with the rendered content.\r\n    partial: function(location, data, callback, partials) {\r\n      if (_isFunction(callback)) {\r\n        // invoked as partial(location, data, callback, [partials])\r\n        return this.render(location, data, partials).swap(callback);\r\n      } else if (_isFunction(data)) {\r\n        // invoked as partial(location, callback, [partials])\r\n        return this.render(location, {}, callback).swap(data);\r\n      } else {\r\n        // invoked as partial(location, data, [partials])\r\n        return this.render(location, data, callback).swap();\r\n      }\r\n    },\r\n\r\n    // defers the call of function to occur in order of the render queue.\r\n    // The function can accept any number of arguments as long as the last\r\n    // argument is a callback function. This is useful for putting arbitrary\r\n    // asynchronous functions into the queue. The content passed to the\r\n    // callback is passed as `content` to the next item in the queue.\r\n    //\r\n    // ### Example\r\n    //\r\n    //     this.send($.getJSON, '/app.json')\r\n    //         .then(function(json) {\r\n    //           $('#message).text(json['message']);\r\n    //          });\r\n    //\r\n    //\r\n    send: function() {\r\n      var context = this,\r\n          args = _makeArray(arguments),\r\n          fun  = args.shift();\r\n\r\n      if (_isArray(args[0])) { args = args[0]; }\r\n\r\n      return this.then(function(content) {\r\n        args.push(function(response) { context.next(response); });\r\n        context.wait();\r\n        fun.apply(fun, args);\r\n        return false;\r\n      });\r\n    },\r\n\r\n    // iterates over an array, applying the callback for each item item. the\r\n    // callback takes the same style of arguments as `jQuery.each()` (index, item).\r\n    // The return value of each callback is collected as a single string and stored\r\n    // as `content` to be used in the next iteration of the `RenderContext`.\r\n    collect: function(array, callback, now) {\r\n      var context = this;\r\n      var coll = function() {\r\n        if (_isFunction(array)) {\r\n          callback = array;\r\n          array = this.content;\r\n        }\r\n        var contents = [], doms = false;\r\n        $.each(array, function(i, item) {\r\n          var returned = callback.apply(context, [i, item]);\r\n          if (returned.jquery && returned.length == 1) {\r\n            returned = returned[0];\r\n            doms = true;\r\n          }\r\n          contents.push(returned);\r\n          return returned;\r\n        });\r\n        return doms ? contents : contents.join('');\r\n      };\r\n      return now ? coll() : this.then(coll);\r\n    },\r\n\r\n    // loads a template, and then interpolates it for each item in the `data`\r\n    // array. If a callback is passed, it will call the callback with each\r\n    // item in the array _after_ interpolation\r\n    renderEach: function(location, name, data, callback) {\r\n      if (_isArray(name)) {\r\n        callback = data;\r\n        data = name;\r\n        name = null;\r\n      }\r\n      return this.load(location).then(function(content) {\r\n          var rctx = this;\r\n          if (!data) {\r\n            data = _isArray(this.previous_content) ? this.previous_content : [];\r\n          }\r\n          if (callback) {\r\n            $.each(data, function(i, value) {\r\n              var idata = {}, engine = this.next_engine || location;\r\n              if (name) { \r\n                idata[name] = value; \r\n              } else { \r\n                idata = value; \r\n              }\r\n              callback(value, rctx.event_context.interpolate(content, idata, engine));\r\n            });\r\n          } else {\r\n            return this.collect(data, function(i, value) {\r\n              var idata = {}, engine = this.next_engine || location;\r\n              if (name) {\r\n                idata[name] = value; \r\n              } else {\r\n                idata = value;\r\n              }\r\n              return this.event_context.interpolate(content, idata, engine);\r\n            }, true);\r\n          }\r\n      });\r\n    },\r\n\r\n    // uses the previous loaded `content` and the `data` object to interpolate\r\n    // a template. `engine` defines the templating/interpolation method/engine\r\n    // that should be used. If `engine` is not passed, the `next_engine` is\r\n    // used. If `retain` is `true`, the final interpolated data is appended to\r\n    // the `previous_content` instead of just replacing it.\r\n    interpolate: function(data, engine, retain) {\r\n      var context = this;\r\n      return this.then(function(content, prev) {\r\n        if (!data && prev) { data = prev; }\r\n        if (this.next_engine) {\r\n          engine = this.next_engine;\r\n          this.next_engine = false;\r\n        }\r\n        var rendered = context.event_context.interpolate(content, data, engine, this.partials);\r\n        return retain ? prev + rendered : rendered;\r\n      });\r\n    },\r\n\r\n    // Swap the return contents ensuring order. See `Application#swap`\r\n    swap: function(callback) {\r\n      return this.then(function(content) {\r\n        this.event_context.swap(content, callback);\r\n        return content;\r\n      }).trigger('changed', {});\r\n    },\r\n\r\n    // Same usage as `jQuery.fn.appendTo()` but uses `then()` to ensure order\r\n    appendTo: function(selector) {\r\n      return this.then(function(content) {\r\n        $(selector).append(content);\r\n      }).trigger('changed', {});\r\n    },\r\n\r\n    // Same usage as `jQuery.fn.prependTo()` but uses `then()` to ensure order\r\n    prependTo: function(selector) {\r\n      return this.then(function(content) {\r\n        $(selector).prepend(content);\r\n      }).trigger('changed', {});\r\n    },\r\n\r\n    // Replaces the `$(selector)` using `html()` with the previously loaded\r\n    // `content`\r\n    replace: function(selector) {\r\n      return this.then(function(content) {\r\n        $(selector).html(content);\r\n      }).trigger('changed', {});\r\n    },\r\n\r\n    // trigger the event in the order of the event context. Same semantics\r\n    // as `Sammy.EventContext#trigger()`. If data is omitted, `content`\r\n    // is sent as `{content: content}`\r\n    trigger: function(name, data) {\r\n      return this.then(function(content) {\r\n        if (typeof data == 'undefined') { data = {content: content}; }\r\n        this.event_context.trigger(name, data);\r\n        return content;\r\n      });\r\n    }\r\n\r\n  });\r\n\r\n  // `Sammy.EventContext` objects are created every time a route is run or a\r\n  // bound event is triggered. The callbacks for these events are evaluated within a `Sammy.EventContext`\r\n  // This within these callbacks the special methods of `EventContext` are available.\r\n  //\r\n  // ### Example\r\n  //\r\n  //       $.sammy(function() {\r\n  //         // The context here is this Sammy.Application\r\n  //         this.get('#/:name', function() {\r\n  //           // The context here is a new Sammy.EventContext\r\n  //           if (this.params['name'] == 'sammy') {\r\n  //             this.partial('name.html.erb', {name: 'Sammy'});\r\n  //           } else {\r\n  //             this.redirect('#/somewhere-else')\r\n  //           }\r\n  //         });\r\n  //       });\r\n  //\r\n  // Initialize a new EventContext\r\n  //\r\n  // ### Arguments\r\n  //\r\n  // * `app` The `Sammy.Application` this event is called within.\r\n  // * `verb` The verb invoked to run this context/route.\r\n  // * `path` The string path invoked to run this context/route.\r\n  // * `params` An Object of optional params to pass to the context. Is converted\r\n  //   to a `Sammy.Object`.\r\n  // * `target` a DOM element that the event that holds this context originates\r\n  //   from. For post, put and del routes, this is the form element that triggered\r\n  //   the route.\r\n  //\r\n  Sammy.EventContext = function(app, verb, path, params, target) {\r\n    this.app    = app;\r\n    this.verb   = verb;\r\n    this.path   = path;\r\n    this.params = new Sammy.Object(params);\r\n    this.target = target;\r\n  };\r\n\r\n  Sammy.EventContext.prototype = $.extend({}, Sammy.Object.prototype, {\r\n\r\n    // A shortcut to the app's `$element()`\r\n    $element: function() {\r\n      return this.app.$element(_makeArray(arguments).shift());\r\n    },\r\n\r\n    // Look up a templating engine within the current app and context.\r\n    // `engine` can be one of the following:\r\n    //\r\n    // * a function: should conform to `function(content, data) { return interpolated; }`\r\n    // * a template path: 'template.ejs', looks up the extension to match to\r\n    //   the `ejs()` helper\r\n    // * a string referring to the helper: \"mustache\" => `mustache()`\r\n    //\r\n    // If no engine is found, use the app's default `template_engine`\r\n    //\r\n    engineFor: function(engine) {\r\n      var context = this, engine_match;\r\n      // if path is actually an engine function just return it\r\n      if (_isFunction(engine)) { return engine; }\r\n      // lookup engine name by path extension\r\n      engine = (engine || context.app.template_engine).toString();\r\n      if ((engine_match = engine.match(/\\.([^\\.\\?\\#]+)$/))) {\r\n        engine = engine_match[1];\r\n      }\r\n      // set the engine to the default template engine if no match is found\r\n      if (engine && _isFunction(context[engine])) {\r\n        return context[engine];\r\n      }\r\n\r\n      if (context.app.template_engine) {\r\n        return this.engineFor(context.app.template_engine);\r\n      }\r\n      return function(content, data) { return content; };\r\n    },\r\n\r\n    // using the template `engine` found with `engineFor()`, interpolate the\r\n    // `data` into `content`\r\n    interpolate: function(content, data, engine, partials) {\r\n      return this.engineFor(engine).apply(this, [content, data, partials]);\r\n    },\r\n\r\n    // Create and return a `Sammy.RenderContext` calling `render()` on it.\r\n    // Loads the template and interpolate the data, however does not actual\r\n    // place it in the DOM.\r\n    //\r\n    // ### Example\r\n    //\r\n    //      // mytemplate.mustache <div class=\"name\">{{name}}</div>\r\n    //      render('mytemplate.mustache', {name: 'quirkey'});\r\n    //      // sets the `content` to <div class=\"name\">quirkey</div>\r\n    //      render('mytemplate.mustache', {name: 'quirkey'})\r\n    //        .appendTo('ul');\r\n    //      // appends the rendered content to $('ul')\r\n    //\r\n    render: function(location, data, callback, partials) {\r\n      return new Sammy.RenderContext(this).render(location, data, callback, partials);\r\n    },\r\n\r\n    // Create and return a `Sammy.RenderContext` calling `renderEach()` on it.\r\n    // Loads the template and interpolates the data for each item,\r\n    // however does not actual place it in the DOM.\r\n    //\r\n    // ### Example\r\n    //\r\n    //      // mytemplate.mustache <div class=\"name\">{{name}}</div>\r\n    //      renderEach('mytemplate.mustache', [{name: 'quirkey'}, {name: 'endor'}])\r\n    //      // sets the `content` to <div class=\"name\">quirkey</div><div class=\"name\">endor</div>\r\n    //      renderEach('mytemplate.mustache', [{name: 'quirkey'}, {name: 'endor'}]).appendTo('ul');\r\n    //      // appends the rendered content to $('ul')\r\n    //\r\n    renderEach: function(location, name, data, callback) {\r\n      return new Sammy.RenderContext(this).renderEach(location, name, data, callback);\r\n    },\r\n\r\n    // create a new `Sammy.RenderContext` calling `load()` with `location` and\r\n    // `options`. Called without interpolation or placement, this allows for\r\n    // preloading/caching the templates.\r\n    load: function(location, options, callback) {\r\n      return new Sammy.RenderContext(this).load(location, options, callback);\r\n    },\r\n\r\n    // create a new `Sammy.RenderContext` calling `loadPartials()` with `partials`.\r\n    loadPartials: function(partials) {\r\n      return new Sammy.RenderContext(this).loadPartials(partials);\r\n    },\r\n\r\n    // `render()` the `location` with `data` and then `swap()` the\r\n    // app's `$element` with the rendered content.\r\n    partial: function(location, data, callback, partials) {\r\n      return new Sammy.RenderContext(this).partial(location, data, callback, partials);\r\n    },\r\n\r\n    // create a new `Sammy.RenderContext` calling `send()` with an arbitrary\r\n    // function\r\n    send: function() {\r\n      var rctx = new Sammy.RenderContext(this);\r\n      return rctx.send.apply(rctx, arguments);\r\n    },\r\n\r\n    // Changes the location of the current window. If `to` begins with\r\n    // '#' it only changes the document's hash. If passed more than 1 argument\r\n    // redirect will join them together with forward slashes.\r\n    //\r\n    // ### Example\r\n    //\r\n    //      redirect('#/other/route');\r\n    //      // equivalent to\r\n    //      redirect('#', 'other', 'route');\r\n    //\r\n    redirect: function() {\r\n      var to, args = _makeArray(arguments),\r\n          current_location = this.app.getLocation(),\r\n          l = args.length;\r\n      if (l > 1) {\r\n        var i = 0, paths = [], pairs = [], params = {}, has_params = false;\r\n        for (; i < l; i++) {\r\n          if (typeof args[i] == 'string') {\r\n            paths.push(args[i]);\r\n          } else {\r\n            $.extend(params, args[i]);\r\n            has_params = true;\r\n          }\r\n        }\r\n        to = paths.join('/');\r\n        if (has_params) {\r\n          for (var k in params) {\r\n            pairs.push(this.app._encodeFormPair(k, params[k]));\r\n          }\r\n          to += '?' + pairs.join('&');\r\n        }\r\n      } else {\r\n        to = args[0];\r\n      }\r\n      this.trigger('redirect', {to: to});\r\n      this.app.last_location = [this.verb, this.path];\r\n      this.app.setLocation(to);\r\n      if (new RegExp(to).test(current_location)) {\r\n        this.app.trigger('location-changed');\r\n      }\r\n    },\r\n\r\n    // Triggers events on `app` within the current context.\r\n    trigger: function(name, data) {\r\n      if (typeof data == 'undefined') { data = {}; }\r\n      if (!data.context) { data.context = this; }\r\n      return this.app.trigger(name, data);\r\n    },\r\n\r\n    // A shortcut to app's `eventNamespace()`\r\n    eventNamespace: function() {\r\n      return this.app.eventNamespace();\r\n    },\r\n\r\n    // A shortcut to app's `swap()`\r\n    swap: function(contents, callback) {\r\n      return this.app.swap(contents, callback);\r\n    },\r\n\r\n    // Raises a possible `notFound()` error for the current path.\r\n    notFound: function() {\r\n      return this.app.notFound(this.verb, this.path);\r\n    },\r\n\r\n    // Default JSON parsing uses jQuery's `parseJSON()`. Include `Sammy.JSON`\r\n    // plugin for the more conformant \"crockford special\".\r\n    json: function(string) {\r\n      return $.parseJSON(string);\r\n    },\r\n\r\n    // //=> Sammy.EventContext: get #/ {}\r\n    toString: function() {\r\n      return \"Sammy.EventContext: \" + [this.verb, this.path, this.params].join(' ');\r\n    }\r\n\r\n  });\r\n\r\n  return Sammy;\r\n});\r\n})(jQuery, window);"]],"start1":67,"start2":67,"length1":18363,"length2":76875}]],"length":76942,"saved":false}
